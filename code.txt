Study plan + must‚Äëknow templates (4 weeks, 6 days/week)
Week 1: Arrays, Hashing, Two Pointers, Sliding Window, Stack
Day 1 (Arrays/Hashing): Product of Array Except Self, Longest Consecutive Sequence, Majority Element, Missing Number.
Day 2 (Intervals + Prefix): Merge Intervals, Non-overlapping Intervals, Merge Sorted Array, Set Matrix Zeroes, Subarray Sum Equals K.
Day 3 (Two Pointers): 3Sum, Container With Most Water, Trapping Rain Water, Backspace String Compare, Remove K Digits.
Day 4 (Sliding Window I): Longest Substring Without Repeating Characters, Permutation in String, Find All Anagrams in a String, Sliding Window Maximum.
Day 5 (Sliding Window II): Longest Repeating Character Replacement, Minimum Window Substring, Decode Ways, Sort Colors.
Day 6 (Review/Mocks): Re‚Äëdo misses; 1 mock timed set (4 problems mixed).
Week 2: Linked Lists, Binary Search, Trees (basics), Heaps/Greedy
Day 1 (Linked List I): Reverse Linked List, Merge Two Sorted Lists, Remove Nth Node From End, Reorder List.
Day 2 (Linked List II): Add Two Numbers, Linked List Cycle, Linked List Cycle II, Palindrome Linked List, Intersection of Two Linked Lists, Copy List with Random Pointer.
Day 3 (Binary Search): Binary Search, First Bad Version, Find Peak Element, Search a 2D Matrix, Search in Rotated Sorted Array, Find Minimum in Rotated Sorted Array, Median of Two Sorted Arrays, Koko Eating Bananas.
Day 4 (Trees I): Invert Binary Tree, Maximum Depth, Balanced Binary Tree, Diameter of Binary Tree, Binary Tree Level Order Traversal, Right Side View.
Day 5 (Heaps/Greedy/Intervals): Kth Largest Element, Task Scheduler, Car Fleet, Largest Rectangle in Histogram, Merge K Sorted Lists, Find Median from Data Stream.
Day 6 (Review/Mocks): Mixed set; revisit weak topics.
Week 3: Graphs, Union-Find, Backtracking, Tries, Matrix BFS
Day 1 (Graphs BFS/DFS): Number of Islands, Clone Graph, Rotting Oranges, Pacific Atlantic Water Flow.
Day 2 (Topo/Ordering): Course Schedule, Alien Dictionary, Graph Valid Tree, Redundant Connection, Network Delay Time, Accounts Merge.
Day 3 (Union-Find): Graph Valid Tree, Redundant Connection, Accounts Merge, Number of Islands (UF variant).
Day 4 (Backtracking): Generate Parentheses, Permutations, Subsets, Combination Sum, Word Search (if in your pool), Word Break.
Day 5 (Trie/Strings): Implement Trie, Add and Search Word, Top K Frequent Words, Encode/Decode Strings.
Day 6 (Review/Mocks): 1 full mock; re‚Äëdo 3 hardest.
Week 4: Dynamic Programming, Advanced Trees, Mixed Review
Day 1 (1D DP): Climbing Stairs, House Robber, House Robber II, Maximum Subarray, Maximum Product Subarray.
Day 2 (Knapsack/Coins): Coin Change, Coin Change II (if in pool), Decode Ways (DP view), Word Break (DP view), Unique Paths.
Day 3 (LIS/Greedy DP): Longest Increasing Subsequence, Russian Doll Envelopes (if in pool), Partition Equal Subset Sum (if in pool).
Day 4 (Tree/Graph DP & Construction): Path Sum, Kth Smallest in BST, Validate BST, LCA, Build Tree from Preorder+Inorder, Serialize/Deserialize.
Day 5 (Mixed hard review): Minimum Window Substring, Sliding Window Maximum, Median of Two Sorted Arrays, Task Scheduler, Word Ladder.
Day 6 (Final mock + reflections): 1‚Äì2 timed mocks; compile a mistakes log.




/**

Anagram: s2 is angram of s1 if s1 chas jumbled. no addtion, subtraction of chars and lenght of s1 == s2.



**/




/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function (strs) {


    let map = new Map();

    for (let str of strs) {
        let counts = new Array(26).fill(0);

        for (let char of str) {

            let alpha = char.charCodeAt(0) - 97;
            ++counts[alpha];
        }

        counts = counts.join(',');

        if (!map.has(counts)) {
            map.set(counts, []);
        }
        map.get(counts).push(str);
    }

    return Array.from(map.values());
};

//111000// ElevenOn1
//111000// OneEleven




/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function (nums, k) {

    let frequency = new Map();
    for (let num of nums) {

        if (!frequency.has(num)) {
            frequency.set(num, 0);
        }
        frequency.set(num, frequency.get(num) + 1);
    }



    let buckets = new Array(nums.length + 1).fill(null).map(() => []);

    for (let [key, value] of frequency.entries()) {
        buckets[value].push(key);
    }

    let ans = [];

    for (let i = buckets.length - 1; i >= 0 && ans.length < k; --i) {

        for (let num of buckets[i]) {

            if (ans.length >= k) {
                break;
            }
            ans.push(num);
        }
    }
    return ans;

};


/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function (nums) {

    let ans = new Array(nums.length).fill(0);

    let prefix = 1;

    for (let i = 0; i < nums.length; i++) {

        ans[i] = prefix;
        prefix *= nums[i];

    }

    let suffix = 1;

    for (let i = nums.length - 1; i >= 0; i--) {

        ans[i] *= suffix;
        suffix *= nums[i];

    }

    return ans;

};


Longest Consecutive Sequence:

/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function (nums) {

    if (nums.length == 0) {
        return 0;
    }


    let uniqueNums = new Set(nums);
    let max = -Infinity;

    for (let num of uniqueNums) {

        if (uniqueNums.has(num - 1)) {
            continue;
        }

        let count = 0;

        while (uniqueNums.has(num)) {

            ++count;
            ++num;
        }
        max = Math.max(max, count);
    }
    return max;
};


Majority Element:

/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function (nums) {

    let count = 0;
    let c = '';

    for (let num of nums) {

        if (count == 0 || c == num) {
            c = num;
            ++count
        } else {
            --count;
        }
    }
    return c;
};


Majority Element 2:

/**
 * @param {number[]} nums
 * @return {number[]}
 */

var majorityElement = function (nums) {


    let e1 = null;
    let e2 = null;
    let count1 = 0;
    let count2 = 0;

    for (let n of nums) {


        if (e1 === n) {
            ++count1;
        }

        else if (e2 === n) {
            ++count2;
        }

        else if (count1 == 0) {
            e1 = n;
            count1 = 1;
        }
        else if (count2 == 0) {
            e2 = n;
            count2 = 1;
        }
        else {

            --count1;
            --count2;

        }
    }

    console.log(e1, e2);

    count1 = 0;
    count2 = 0;
    for (let num of nums) {
        if (num === e1) count1++;
        else if (num === e2) count2++;
    }




    let c = Math.floor(nums.length / 3);
    let ans = [];

    if (count1 > c) {
        ans.push(e1);
    }

    if (count2 > c) {
        ans.push(e2);
    }

    return ans;

};



Missing Number:


/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    let n = nums.length;
    let expectedSum = (n * (n + 1)) / 2;
    let actualSum = nums.reduce((a, b) => a + b, 0);
    return expectedSum - actualSum;
};


var missingNumber = function(nums) {
    let n = nums.length;
    let xor = 0;

    for (let i = 0; i <= n; i++) {
        xor ^= i;
    }
    for (let num of nums) {
        xor ^= num;
    }
    return xor;
};




Merge Intervals:


/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    if (intervals.length <= 1) return intervals;

    // Step 1: Sort by start time
    intervals.sort((a, b) => a[0] - b[0]);

    let merged = [intervals[0]];

    // Step 2: Merge overlaps
    for (let i = 1; i < intervals.length; i++) {
        let last = merged[merged.length - 1];
        let current = intervals[i];

        if (current[0] <= last[1]) {
            // Overlap ‚Üí merge
            last[1] = Math.max(last[1], current[1]);
        } else {
            // No overlap ‚Üí push new interval
            merged.push(current);
        }
    }

    return merged;
};


/**
 * @param {number[][]} intervals
 * @return {number}
 */
var eraseOverlapIntervals = function (intervals) {

    intervals.sort((a, b) => {

        if (a[0] != b[0]) {
            return a[0] - b[0];
        }
        else {
            return a[1] - b[1];
        }
    });
    let count = 0;
    let prevEnd = intervals[0][1];

    for (let i = 1; i < intervals.length; i++) {

        if (prevEnd > intervals[i][0]) {
            ++count;
            prevEnd = Math.min(prevEnd, intervals[i][1]);
        }
        else {
            prevEnd = intervals[i][1];
        }
    }

    return count;
};



/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function (matrix) {

    let rc = matrix.length;
    let cc = matrix[0].length;
    let isFirstRowZero = false;
    let isFirstColZero = false;

    for (let i = 0; i < rc; i++) {
        if (matrix[i][0] == 0) {
            isFirstColZero = true;
            break;
        }
    }

    for (let i = 0; i < cc; i++) {
        if (matrix[0][i] == 0) {
            isFirstRowZero = true;
            break;
        }
    }

    for (let i = 1; i < rc; i++) {

        for (let j = 1; j < cc; j++) {

            if (matrix[i][j] == 0) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }

    for (let i = 1; i < rc; i++) {
        for (let j = 1; j < cc; j++) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }

    if (isFirstColZero) {
        for (let i = 0; i < rc; i++) {
            matrix[i][0] = 0
        }

    }

    if (isFirstRowZero) {
        for (let i = 0; i < cc; i++) {
            matrix[0][i] = 0
        }

    }
}



Subarray Sum Equals K:

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarraySum = function (nums, k) {

    let map = new Map();
    map.set(0, 1);
    let sum = 0;
    let count = 0;

    for (let num of nums) {

        sum += num;

        if (map.has(sum - k)) {

            count += map.get(sum - k);
        }

        map.set(sum, (map.get(sum) || 0) + 1);
    }
    return count;

};



3Sum:

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {


    nums.sort((a, b) => a - b);
    const ans = [];

    for (let i = 0; i < nums.length - 2; i++) {

        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }

        let left = i + 1;
        let right = nums.length - 1;

        while (left < right) {

            let sum = nums[i] + nums[left] + nums[right];

            if (sum == 0) {

                ans.push([nums[i], nums[left], nums[right]]);
                while (left < right && nums[left] == nums[left + 1]) {
                    ++left;
                }
                while (left < right && nums[right] == nums[right - 1]) {
                    --right;
                }
                ++left;
                --right;
            }
            else if (sum > 0) {

                --right;
            }
            else {
                ++left;
            }
        }
    }
    return ans;
};


Container With Most Water:

/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function (height) {

    let left = 0;
    let right = height.length - 1;
    let ans = -Infinity;

    while (left < right) {

        let cap = (right - left) * Math.min(height[left], height[right]);
        ans = Math.max(ans, cap);

        if (height[left] > height[right]) {
            --right;
        }
        else {
            ++left;
        }
    }

    return ans;

};



Trapping Rain Water:

Solution:

/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function (nums) {


    let left = new Array(nums.length).fill(0);
    let right = new Array(nums.length).fill(0);
    let ans = 0;
    let i = 0;
    left[i] = nums[i];;

    for (let i = 1; i < nums.length; i++) {
        left[i] = Math.max(nums[i], left[i - 1]);
    }
    left[0] = -1;

    right[nums.length - 1] = nums[nums.length - 1];

    for (let i = nums.length - 2; i >= 0; --i) {
        right[i] = Math.max(nums[i], right[i + 1]);
    }

    right[nums.length - 1] = -1

    for (let i = 0; i < nums.length; i++) {
        let c = (Math.min(left[i], right[i]) - nums[i]);
        if (c > 0) {
            ans += c;
        }
    }

    return ans;

};


/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function (nums) {


    let left = 1;
    let right = nums.length - 2;
    let ans = 0;
    let lMax = nums[0];
    let rMax = nums[nums.length - 1];

    while (left <= right) {

        if (rMax > lMax) {

            let cap = (lMax - nums[left]);
            lMax = Math.max(lMax, nums[left]);
            if (cap > 0) {
                ans += cap;
            }
            ++left;
        }
        else {

            let cap = (rMax - nums[right]);
            rMax = Math.max(rMax, nums[right]);
            if (cap > 0) {
                ans += cap;
            }
            --right;
        }
    }



    return ans;


};



Backspace String Compare:

var backspaceCompare = function (s, t) {
    let i = s.length - 1, j = t.length - 1;
    let skipS = 0, skipT = 0;

    while (i >= 0 || j >= 0) {
        // Move i
        while (i >= 0) {
            if (s[i] === '#') { skipS++; i--; }
            else if (skipS > 0) { skipS--; i--; }
            else break;
        }

        // Move j
        while (j >= 0) {
            if (t[j] === '#') { skipT++; j--; }
            else if (skipT > 0) { skipT--; j--; }
            else break;
        }

        let sc = s[i] ? s[i] : null;
        let tc = t[j] ? t[j] : null;

        if (s[i] !== t[j]) {
            return false;
        }
        i--; j--;
    }
    return true;
};




/**
 * @param {string} num
 * @param {number} k
 * @return {string}
 */
var removeKdigits = function (num, k) {


    let stack = [];

    for (let n of num) {

        while (k > 0 && stack.length > 0 && stack[stack.length - 1] > n) {

            stack.pop();
            --k;
        }
        stack.push(n);
    }


    while (k > 0) {
        stack.pop();
        --k;
    }
    while (stack[0] == 0) {

        stack.shift();

    }

    return stack.join('') || '0';
};


/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {


    let seen = new Map();
    let left = 0;
    let ans = 0;

    for (let right = 0; right < s.length; ++right) {

        let c = s[right];

        if (seen.has(c) && seen.get(c) >= left) {
            left = seen.get(c) + 1;
        }

        seen.set(c, right);
        ans = Math.max(ans, right - left + 1);
    }

    return ans;
}



/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var checkInclusion = function (s1, s2) {

    if (s1.length > s2.length) {
        return false;
    }

    let char1 = new Array(26).fill(0);
    let char2 = new Array(26).fill(0);

    let i;

    for (i = 0; i < s1.length; i++) {

        let code1 = s1[i].charCodeAt(0) - 97;
        let code2 = s2[i].charCodeAt(0) - 97;
        ++char1[code1];
        ++char2[code2];
    }

    char1 = char1.join('');

    if (char1 == char2.join('')) {
        return true;
    }

    let j = 0;

    for (i; i < s2.length; i++, j++) {

        let code1 = s2[j].charCodeAt(0) - 97;
        let code2 = s2[i].charCodeAt(0) - 97;
        --char2[code1];
        ++char2[code2];

        if (char1 == char2.join('')) {
            return true;
        }
    }
    return false;
};




/**
 * @param {string} s
 * @param {string} p
 * @return {number[]}
 */
var findAnagrams = function (s2, s1) {

    if (s1.length > s2.length) {

        return [];
    }

    let char1 = new Array(26).fill(0);
    let char2 = new Array(26).fill(0);

    let ans = [];

    let i;

    for (i = 0; i < s1.length; i++) {


        let code1 = s1[i].charCodeAt(0) - 97;
        let code2 = s2[i].charCodeAt(0) - 97;
        ++char1[code1];
        ++char2[code2];
    }

    char1 = char1.join('');

    if (char1 == char2.join('')) {
        ans.push(0);
    }

    let j = 0;

    for (i; i < s2.length; i++) {

        let code1 = s2[j].charCodeAt(0) - 97;
        let code2 = s2[i].charCodeAt(0) - 97;
        ++char2[code2];
        --char2[code1];
        ++j;

        if (char1 == char2.join('')) {
            ans.push(j);
        }
    }

    return ans;

};



/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var characterReplacement = function (s, k) {

    let left = 0;
    let right = 0;
    let ans = -Infinity;
    let chars = new Array(26).fill(0);
    let maxF = 0;

    while (right < s.length) {

        let code = s[right].charCodeAt(0) - 65;
        ++chars[code];

        maxF = Math.max(maxF, chars[code]);

        let length = right - left + 1;

        if (length > (maxF + k)) {

            code = s[left].charCodeAt(0) - 65;
            --chars[code];
            ++left;
        }
        ans = Math.max(ans, right - left + 1);
        ++right

    }

    return ans;
};



Decode Ways:

/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function (s) {


    let map = new Map();
    let cache = new Map();

    for (let i = 0; i < 26; i++) {
        map.set(`${i + 1}`, String.fromCharCode(65 + i));
    }

    let travel = (i) => {


        if (i < 0) {
            return 1;
        }

        if (cache.has(i)) {
            return cache.get(i);
        }

        let res = 0;

        if (map.has(s[i])) {
            res = travel(i - 1);
        }

        if (map.has(s[i - 1] + s[i])) {
            res += travel(i - 2);
        }

        cache.set(i, res);

        return res;
    }
    return travel(s.length - 1);

};



/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var sortColors = function (nums) {


    let i = 0;
    let left = 0;
    let right = nums.length - 1;

    while (i <= right) {


        if (nums[i] == 0) {
            [nums[left], nums[i]] = [nums[i], nums[left]];
            ++left;
            ++i; // incrementing as at pos left 2 never comes as it already moved to right pos.
        }

        else if (nums[i] == 2) {
            [nums[right], nums[i]] = [nums[i], nums[right]];
            --right;
        }
        else {
            ++i;
        }
    }
    return nums;
}



/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function (nums, k) {

    let t = [];
    let ans = [];
    k = k - 1;

    for (let i = 0; i < nums.length; i++) {

        if (t.length && (i - k) > t[0]) {
            t.shift();
        }

        while (t.length && nums[i] >= nums[t[t.length - 1]]) {
            t.pop();
        }

        t.push(i);

        if (i >= k) {
            ans.push(nums[t[0]]);
        }
    }

    return ans;
};



/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function (s, t) {

    const map1 = new Map();
    const map2 = new Map();
    let left = 0;
    let ans = '';

    for (let c of t) {
        map1.set(c, (map1.get(c) || 0) + 1);
    }

    let req = map1.size;
    let have = 0;

    for (let right = 0; right < s.length; ++right) {

        let c = s[right];

        map2.set(c, (map2.get(c) || 0) + 1);

        if (map2.get(c) == map1.get(c)) {
            ++have;
        }

        if (req == have) {

            let start = left;

            while (left <= right) {

                let c = s[left];
                start = left;

                map2.set(c, map2.get(c) - 1);

                if (map1.get(c) > map2.get(c)) {
                    --have;
                    ++left;
                    break;
                }

                ++left;
            }

            if (!ans || ans.length > (right - left + 1)) {
                ans = s.substring(start, right + 1);
            }

        }
    }

    return ans;

};


Reverse Linked List:

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {

    let travel = (p, q) => {

        if (!p) {
            return q;
        }
        let r = p.next;
        p.next = q;
        q = p;

        return travel(r, q);
    }

    return travel(head, null)


};


Merge Two Sorted Lists:

/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function (list1, list2) {

    let head = new ListNode(0, null);
    let temp = head;
    
    while (list1 && list2) {

        if (list1.val >= list2.val) {

            temp.next = list2;
            list2 = list2.next;
        }
        else {
            temp.next = list1;
            list1 = list1.next;
        }

        temp = temp.next;

    }

    if (!list1) {
        temp.next = list2;
    }
    else {
        temp.next = list1;
    }
    return head.next;


};


 Remove Nth Node From End:


/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {

    let s = new ListNode(0, null);
    f = s;
    s.next = head;
    head=s;

    let i = 0;;
    while (i < n) {
        f = f.next;
        ++i;
    }

    while (f.next) {
        f = f.next;
        s = s.next;
    }

    s.next=s.next.next;
    return head.next;

};

Reorder List:

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {void} Do not return anything, modify head in-place instead.
 */
var reorderList = function (head) {

    let reverse = (head) => {
        let p = head;
        let q = null;
        while (p) {
            let r = p.next;
            p.next = q;
            q = p;
            p = r;
        }
        return q;
    }
    
    let slow = head;
    let fast = head;

    while (fast && fast.next && fast.next.next) {
        slow = slow.next;
        fast = fast.next.next;
    }

    let l2 = slow.next;
    let l1 = head;
    slow.next = null;
    l2 = reverse(l2);

    while (l1 && l2) {
        let p = l1.next;
        let q = l2.next;
        l1.next = l2;
        l2.next = p;
        l1 = p;
        l2 = q;
    }
    return head;
};



Linked List Cycle II:


/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var detectCycle = function (head) {

    let slow = head;
    let fast = head;

    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;

        if (slow == fast) {
            slow = head;
            while (slow != fast) {
                slow = slow.next;
                fast = fast.next;
            }
            return slow;
        }
    }
    return null;
};


// Sure üëç here‚Äôs the 4-line explanation of the formula L + x = kC:

// Let L = distance from head to cycle start, x = distance from cycle start to meeting point, C = cycle length.

// At meeting, slow has traveled L + x.

// Fast has traveled L + x + kC (same path as slow + k full cycles).

// Since fast moves twice as fast: L + x + kC = 2(L + x) ‚Üí L + x = kC.

// Would you like me to also give you a one-liner intuition (non-mathy) you can remember easily?



Intersection of Two Linked Lists:

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function (headA, headB) {

    let a = headA;
    let b = headB;

    while (a || b) {

        if (a == null) {
            a = headB
        }
        if (b == null) {
            b = headA;
        }

        if (a == b) {
            return a;
        }
        
        a = a.next;
        b = b.next;

    }
};


/**
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function (nums) {

    nums.unshift(-Infinity);
    nums.push(-Infinity);

    let beg = 1;
    let end = nums.length - 2;

    while (beg <= end) {

        let mid = Math.floor((beg + end) / 2);

        if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {
            return mid - 1;
        }

        if (nums[mid + 1] > nums[mid]) {
            beg = mid + 1;
        }
        else {
            end = mid - 1;
        }
    }
};

/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function (matrix, target) {

    let row = matrix.length;
    let col = matrix[0].length;
    let beg = 0;
    let end = row * col - 1;

    while (beg <= end) {

        let mid = (beg + end) >> 1;

        let i = Math.floor(mid / col);
        let j = mid % col;

        if(matrix[i][j]==target){
            return true;
        }
        else if(matrix[i][j]>target){
            end=mid-1;
        }
        else{
            beg=mid+1;
        }
    }
    return false;

};


Search in Rotated Sorted Array:

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function (nums, target) {


    let beg = 0;
    let end = nums.length - 1;

    while (beg <= end) {

        let mid = (beg + end) >> 1;

        if (nums[mid] == target) {
            return mid;
        }
        else if (nums[mid] >= nums[beg]) {

            if (target >= nums[beg] && target < nums[mid]) {

                end = mid - 1;
            }
            else {
                beg = mid + 1;
            }
        }
        else {

            if (target > nums[mid] && target <= nums[end]) {

                beg = mid + 1;
            }
            else {
                end = mid - 1;
            }
        }
    }

    return -1;
};


Find Minimum in Rotated Sorted Array:


/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var findMin = function (nums) {

    let beg = 0;
    let end = nums.length - 1;
    let min = Infinity;


    while (beg <= end) {

        let mid = (beg + end) >> 1;

        if (nums[mid] >= nums[beg]) {

            min = Math.min(min, nums[beg]);
            beg = mid + 1;
        }
        else {
            min = Math.min(min, nums[end]);
            end = mid - 1;
        }
    }

    return min;
};


Koko Eating Bananas:

/**
 * @param {number[]} piles
 * @param {number} h
 * @return {number}
 */
var minEatingSpeed = function (piles, h) {

    const canEatAll = (k) => {

        let count = 0;

        for (let pile of piles) {

            count += (Math.ceil(pile / k));
            if (count > h) {
                return false;
            }
        }
        return true;
    }

    let left = 0;
    let right = Math.max(...piles);
    let ans = Infinity;

    while (left <= right) {

        let mid = (left + right) >> 1;

        if (canEatAll(mid)) {

            ans = Math.min(ans, mid);
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
    }
    return ans;

};


Invert Binary Tree:

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function (root) {


    let travel = (root) => {

        if (!root) {
            return root;
        }

        let left = root.left;
        root.left = root.right;
        root.right = left;

        travel(root.left);
        travel(root.right);
        return root;
    }

    return travel(root)

};



Maximum Depth:

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {


    let depth = (root) => {

        if (!root) {
            return 0;
        }

        let left = 1 + depth(root.left);
        let right = 1 + depth(root.right);

        return Math.max(left,right);
    }

    return depth(root);


}



Balanced Binary Tree:


/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var isBalanced = function (root) {


    let travel = (root) => {

        if (!root) {
            return 0;
        }

        let left = 1 + travel(root.left);
        let right = 1 + travel(root.right);

        if (Math.abs(left - right) > 1) {
            return Infinity;
        }

        return Math.max(left, right);

    }
    return travel(root) == Infinity ? false : true;

};


//Diameter of Binary Tree


/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function (root) {

    let max = -Infinity;

    let travel = (root) => {

        if (!root) {
            return 0;
        }
        let left = 0;

        if (root.left) {
            left = 1 + travel(root.left);
        }

        let right = 0;

        if (root.right) {
            right = 1 + travel(root.right);
        }

        max = Math.max(max, left + right);
        return Math.max(left, right);
    }

    travel(root);
    return max;
};



//Binary Tree Level Order Traversal

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function (root) {

    if (!root) {
        return [];
    }

    let ans = [];

    let queue = [root];

    while (queue.length > 0) {

        let t = [];
        let i = queue.length;

        while (i > 0) {

            let node = queue.shift();
            t.push(node.val);
            if (node.left) {
                queue.push(node.left);
            }
            if (node.right) {
                queue.push(node.right);
            }
            --i;

        }
        ans.push(t);
    }
    return ans;

};


//Right Side View

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function (root) {

    if (!root) {
        return [];
    }

    let queue = [root];
    let ans = [];

    while (queue.length > 0) {

        let size = queue.length;

        for (let i = 0; i < size; i++) {

            let node = queue.shift();

            if (i == size - 1) {
                ans.push(node.val);
            }

            if (node.left) {
                queue.push(node.left);
            }
            if (node.right) {
                queue.push(node.right);
            }
        }
    }
    return ans;
};


//Kth Largest Element


var findKthLargest = function (nums, k) {

    const heap = [];

    const build = (i) => {

        heap.push(nums[i]);
        i = heap.length - 1;
        let p = Math.floor((i - 1) / 2);
        while (p >= 0 && heap[i] > heap[p]) {
            [heap[i], heap[p]] = [heap[p], heap[i]];
            i = p;
            p = Math.floor((i - 1) / 2);
        }
    }

    const heapifyDown = () => {

        let n = heap.length - 1;
        [heap[0], heap[n]] = [heap[n], heap[0]];
        let e = heap.pop();

        let root = 0;
        let p = 0;

        while (true) {

            let left = 2 * root + 1;
            let right = 2 * root + 2;

            if (left <= n && heap[left] > heap[p]) {
                p = left;
            }

            if (right <= n && heap[right] > heap[p]) {
                p = right;
            }
            if (root == p) {
                break;
            }

            [heap[root], heap[p]] = [heap[p], heap[root]];
            root = p;
        }
        return e;
    }

    for (let i = 0; i < nums.length; i++) {
        build(i);
    }

    let ans = -1;

    for (let i = 0; i < k; i++) {
        ans = heapifyDown();
    }
    return ans;

};



carFleet:

/**
 * @param {number} target
 * @param {number[]} position
 * @param {number[]} speed
 * @return {number}
 */
var carFleet = function (target, position, speed) {


    let cars = [];
    let maxTime = 0;
    let count = 0;

    for (let i = 0; i < position.length; i++) {
        let time = (target - position[i]) / speed[i];
        cars.push([position[i], time]);
    }
    cars.sort((a, b) => b[0] - a[0]);

    for (let car of cars) {

        if (car[1] > maxTime) {
            ++count;
            maxTime = car[1];
        }
    }
    return count;


};


//Task Scheduler

/**
 * @param {character[]} tasks
 * @param {number} n
 * @return {number}
 */
var leastInterval = function (tasks, n) {

    let map = new Map();

    for (let task of tasks) {

        if (!map.has(task)) {
            map.set(task, 0);
        }
        map.set(task, map.get(task) + 1);
    }

    let time = 0;
    let heap = [...map.values()];
    let cooldown = [];


    while (heap.length > 0 || cooldown.length > 0) {

        ++time;
        heap.sort((a, b) => b - a);

        if (heap.length > 0) {

            let job = heap.shift() - 1;
            if (job > 0) {
                cooldown.push([time + n, job]);
            }
        }
        if (cooldown.length > 0 && cooldown[0][0] == time) {
            heap.push(cooldown[0][1]);
            cooldown.shift();
        }
    }
    return time;

};



//Largest Rectangle in Histogram

/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function (heights) {


    heights.unshift(-Infinity);
    heights.push(-Infinity);

    let left = new Array(heights.length).fill(0);
    let right = new Array(heights.length).fill(0);
    let stk = [];

    for (let i = 0; i < heights.length - 1; i++) {

        if (stk.length == 0) {
            stk.push(i);
            continue;
        }

        while (stk.length > 0 && heights[stk[stk.length - 1]] >= heights[i]) {
            stk.pop();
        }

        left[i] = stk[stk.length - 1];

        stk.push(i);
    }

    stk = [];
    for (let i = heights.length - 1; i > 0; i--) {


        if (stk.length == 0) {
            stk.push(i);
            continue;
        }

        while (stk.length > 0 && heights[stk[stk.length - 1]] >= heights[i]) {
            stk.pop();
        }

        right[i] = stk[stk.length - 1];


        stk.push(i);
    }

    //console.log(left, right);


    let max = -Infinity;

    for (let i = 1; i < heights.length - 1; i++) {

        let w = right[i] - left[i] - 1;

        max = Math.max(max, w * heights[i]);
    }
    return max;

};



// merge-k-sorted-lists


/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function (lists) {

    const heap = [];
    const dummy = new ListNode();
    let head = dummy;

    const heapifyUp = (e) => {
        if (!e) {
            return;
        }


        heap.push(e);

        let n = heap.length - 1;
        let p = Math.floor((n - 1) / 2);
        while (p >= 0 && heap[n].val < heap[p].val) {
            [heap[p], heap[n]] = [heap[n], heap[p]];
            n = p;
            p = Math.floor((n - 1) / 2);
        }
    }

    const heapifyDown = () => {

        let node = heap[0];
        let nextNode = node.next;
        node.next = null;

        if (nextNode) {
            heap[0] = nextNode;
        }
        else {
            heap[0] = heap[heap.length - 1];
            heap.pop();
        }

        let n = heap.length - 1;
        let parent = 0;
        let current = 0;

        while (true) {

            let left = 2 * current + 1;
            let right = 2 * current + 2;

            if (left <= n && heap[left].val < heap[current].val) {
                current = left;
            }

            if (right <= n && heap[right].val < heap[current].val) {
                current = right;
            }

            if (parent == current) {
                break;
            }

            [heap[parent], heap[current]] = [heap[current], heap[parent]];

            parent = current;
        }
        return node;
    }

    for (let list of lists) {

        heapifyUp(list);
    }
    //console.log(heap);

    while (heap.length > 0) {
        head.next = heapifyDown();
        head = head.next;
        //console.log(head.val, heap)
    }

    return dummy.next;

};




//Find Median from Data Stream
//For every insertion move max from left to right and min from right to left.

let left = [];
let right = [];

let leftPush = function (num) {

    left.push(num);
    let n = left.length - 1;
    let i = Math.floor((n - 1) / 2);
    while (i >= 0 && left[n] > left[i]) {

        [left[i], left[n]] = [left[n], left[i]];
        n = i;
        i = Math.floor((n - 1) / 2);
    }
}

let rightPush = function (num) {

    right.push(num);
    let n = right.length - 1;
    let i = Math.floor((n - 1) / 2);
    while (i >= 0 && right[n] < right[i]) {

        [right[i], right[n]] = [right[n], right[i]];
        n = i;
        i = Math.floor((n - 1) / 2);
    }
}

let leftDown = function () {

    let current = 0;
    let root = 0;
    let n = left.length;
    while (true) {

        let i = 2 * current + 1; //left child
        let j = 2 * current + 2; // right child

        if (i < n && left[i] > left[current]) {
            current = i;
        }
        if (j < n && left[j] > left[current]) {
            current = j;
        }

        if (current == root) {
            break;
        }
        [left[current], left[root]] = [left[root], left[current]];
        root = current;

    }
}

let rightDown = function () {
    let current = 0;
    let root = 0;
    let n = left.length;
    while (true) {

        let i = 2 * current + 1; //left child
        let j = 2 * current + 2; // right child

        if (i < n && right[i] < right[current]) {
            current = i;
        }
        if (j < n && right[j] < right[current]) {
            current = j;
        }
        if (current == root) {
            break;
        }
        [right[current], right[root]] = [right[root], right[current]];
        root = current;
    }
}

var MedianFinder = function () {
    left = [];
    right = [];
};
/** 
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function (num) {

    leftPush(num);
    let e = left[0];
    left[0] = left[left.length - 1];
    left.pop();
    leftDown();
    rightPush(e);
    if (right.length > left.length) {

        //console.log(left, right)

        let e = right[0];
        right[0] = right[right.length - 1];
        right.pop();
        rightDown();
        leftPush(e);
    }
};

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function () {

    if ((left.length + right.length) % 2 == 0) {

        return (left[0] + right[0]) / 2;
    }
    else {
        return left[0];
    }
};

/** 
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */



//Number of Islands

/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function (grid) {

    let rows = grid.length;
    let cols = grid[0].length;

    let count = 0;

    let travel = (i, j) => {

        if (i < 0 || j < 0 || i >= rows || j >= cols || grid[i][j] == "0") {
            return;
        }

        grid[i][j] = "0";
        travel(i + 1, j);
        travel(i - 1, j);
        travel(i, j + 1);
        travel(i, j - 1);

    }

    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {

            if (grid[i][j] == "1") {

                ++count;
                travel(i, j);
            }
        }
    }

    return count;

};


/**
 * // Definition for a _Node.
 * function _Node(val, neighbors) {
 *    this.val = val === undefined ? 0 : val;
 *    this.neighbors = neighbors === undefined ? [] : neighbors;
 * };
 */

/**
 * @param {_Node} node
 * @return {_Node}
 */
var cloneGraph = function (node) {

    if (!node) {
        return node;
    }

    let nc = new _Node();
    let vis = new Map();

    console.log(node);

    let travel = (nc, node) => {

        //console.log(nc, node)

        if (vis.has(node.val)) {
            return vis.get(node.val);
        }

        vis.set(node.val,nc);

        nc.val = node.val;

        for (let nbr of node.neighbors) {

            let n1 = new _Node();
            nc.neighbors.push(travel(n1, nbr));
            
        }
        return nc;
    }
    let ans=travel(nc, node);

    console.log(ans);
    return ans;
};


//Rotting Oranges

/**
 * @param {number[][]} grid
 * @return {number}
 */
var orangesRotting = function (grid) {

    let count = 0;
    let queue = [];
    let m = grid.length;
    let n = grid[0].length;

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {

            if (grid[i][j] == 2) {
                queue.push([i, j]);

            }
        }
    }
    //console.log(queue)

    while (queue.length > 0) {

        let t = [];
        for (let node of queue) {

            let [i, j] = node;


            if ((i - 1) >= 0) {

                if (grid[i - 1][j] == 1) {

                    grid[i - 1][j] = 2;
                    t.push([i - 1, j])
                }
            }
            if ((i + 1) < m) {

                if (grid[i + 1][j] == 1) {

                    grid[i + 1][j] = 2;

                    t.push([i + 1, j])
                }
            }

            if ((j - 1) >= 0) {
                if (grid[i][j - 1] == 1) {

                    grid[i][j - 1] = 2;
                    t.push([i, j - 1])
                }
            }
            if ((j + 1) < n) {

                if (grid[i][j + 1] == 1) {

                    grid[i][j + 1] = 2;
                    t.push([i, j + 1])
                }
            }
        }
        queue = t;
        if (queue.length > 0) {
            ++count;
        }

    }

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {

            if (grid[i][j] == 1) {
                return -1;

            }
        }
    }

    return count;

};

//console.log(orangesRotting([[1,2]]))
