Study plan + must‑know templates (4 weeks, 6 days/week)
Week 1: Arrays, Hashing, Two Pointers, Sliding Window, Stack
Day 1 (Arrays/Hashing): Product of Array Except Self, Longest Consecutive Sequence, Majority Element, Missing Number.
Day 2 (Intervals + Prefix): Merge Intervals, Non-overlapping Intervals, Merge Sorted Array, Set Matrix Zeroes, Subarray Sum Equals K.
Day 3 (Two Pointers): 3Sum, Container With Most Water, Trapping Rain Water, Backspace String Compare, Remove K Digits.
Day 4 (Sliding Window I): Longest Substring Without Repeating Characters, Permutation in String, Find All Anagrams in a String, Sliding Window Maximum.
Day 5 (Sliding Window II): Longest Repeating Character Replacement, Minimum Window Substring, Decode Ways, Sort Colors.
Day 6 (Review/Mocks): Re‑do misses; 1 mock timed set (4 problems mixed).
Week 2: Linked Lists, Binary Search, Trees (basics), Heaps/Greedy
Day 1 (Linked List I): Reverse Linked List, Merge Two Sorted Lists, Remove Nth Node From End, Reorder List.
Day 2 (Linked List II): Add Two Numbers, Linked List Cycle, Linked List Cycle II, Palindrome Linked List, Intersection of Two Linked Lists, Copy List with Random Pointer.
Day 3 (Binary Search): Binary Search, First Bad Version, Find Peak Element, Search a 2D Matrix, Search in Rotated Sorted Array, Find Minimum in Rotated Sorted Array, Median of Two Sorted Arrays, Koko Eating Bananas.
Day 4 (Trees I): Invert Binary Tree, Maximum Depth, Balanced Binary Tree, Diameter of Binary Tree, Binary Tree Level Order Traversal, Right Side View.
Day 5 (Heaps/Greedy/Intervals): Kth Largest Element, Task Scheduler, Car Fleet, Largest Rectangle in Histogram, Merge K Sorted Lists, Find Median from Data Stream.
Day 6 (Review/Mocks): Mixed set; revisit weak topics.
Week 3: Graphs, Union-Find, Backtracking, Tries, Matrix BFS
Day 1 (Graphs BFS/DFS): Number of Islands, Clone Graph, Rotting Oranges, Pacific Atlantic Water Flow.
Day 2 (Topo/Ordering): Course Schedule, Alien Dictionary, Graph Valid Tree, Redundant Connection, Network Delay Time, Accounts Merge.
Day 3 (Union-Find): Graph Valid Tree, Redundant Connection, Accounts Merge, Number of Islands (UF variant).
Day 4 (Backtracking): Generate Parentheses, Permutations, Subsets, Combination Sum, Word Search (if in your pool), Word Break.
Day 5 (Trie/Strings): Implement Trie, Add and Search Word, Top K Frequent Words, Encode/Decode Strings.
Day 6 (Review/Mocks): 1 full mock; re‑do 3 hardest.
Week 4: Dynamic Programming, Advanced Trees, Mixed Review
Day 1 (1D DP): Climbing Stairs, House Robber, House Robber II, Maximum Subarray, Maximum Product Subarray.
Day 2 (Knapsack/Coins): Coin Change, Coin Change II (if in pool), Decode Ways (DP view), Word Break (DP view), Unique Paths.
Day 3 (LIS/Greedy DP): Longest Increasing Subsequence, Russian Doll Envelopes (if in pool), Partition Equal Subset Sum (if in pool).
Day 4 (Tree/Graph DP & Construction): Path Sum, Kth Smallest in BST, Validate BST, LCA, Build Tree from Preorder+Inorder, Serialize/Deserialize.
Day 5 (Mixed hard review): Minimum Window Substring, Sliding Window Maximum, Median of Two Sorted Arrays, Task Scheduler, Word Ladder.
Day 6 (Final mock + reflections): 1–2 timed mocks; compile a mistakes log.


E:
Two Sum, Contains Duplicate, Valid Anagram, 

M:

/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function (strs) {


    let map = new Map();

    for (let str of strs) {
        let counts = new Array(26).fill(0);

        for (let char of str) {

            let alpha = char.charCodeAt(0) - 97;
            ++counts[alpha];
        }

        counts = counts.join(',');

        if (!map.has(counts)) {
            map.set(counts, []);
        }
        map.get(counts).push(str);
    }

    return Array.from(map.values());
};

//111000// ElevenOn1
//111000// OneEleven




/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function (nums, k) {

    let frequency = new Map();
    for (let num of nums) {

        if (!frequency.has(num)) {
            frequency.set(num, 0);
        }
        frequency.set(num, frequency.get(num) + 1);
    }



    let buckets = new Array(nums.length + 1).fill(null).map(() => []);

    for (let [key, value] of frequency.entries()) {
        buckets[value].push(key);
    }

    let ans = [];

    for (let i = buckets.length - 1; i >= 0 && ans.length < k; --i) {

        for (let num of buckets[i]) {

            if (ans.length >= k) {
                break;
            }
            ans.push(num);
        }
    }
    return ans;

};


/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function (nums) {

    let ans = new Array(nums.length).fill(0);

    let prefix = 1;

    for (let i = 0; i < nums.length; i++) {

        ans[i] = prefix;
        prefix *= nums[i];

    }

    let suffix = 1;

    for (let i = nums.length - 1; i >= 0; i--) {

        ans[i] *= suffix;
        suffix *= nums[i];

    }

    return ans;

};


Longest Consecutive Sequence:

/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function (nums) {

    if (nums.length == 0) {
        return 0;
    }


    let uniqueNums = new Set(nums);
    let max = -Infinity;

    for (let num of uniqueNums) {

        if (uniqueNums.has(num - 1)) {
            continue;
        }

        let count = 0;

        while (uniqueNums.has(num)) {

            ++count;
            ++num;
        }
        max = Math.max(max, count);
    }
    return max;
};


Majority Element:

/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function (nums) {

    let count = 0;
    let c = '';

    for (let num of nums) {

        if (count == 0 || c == num) {
            c = num;
            ++count
        } else {
            --count;
        }
    }
    return c;
};


Majority Element 2:

/**
 * @param {number[]} nums
 * @return {number[]}
 */

var majorityElement = function (nums) {


    let e1 = null;
    let e2 = null;
    let count1 = 0;
    let count2 = 0;

    for (let n of nums) {


        if (e1 === n) {
            ++count1;
        }

        else if (e2 === n) {
            ++count2;
        }

        else if (count1 == 0) {
            e1 = n;
            count1 = 1;
        }
        else if (count2 == 0) {
            e2 = n;
            count2 = 1;
        }
        else {

            --count1;
            --count2;

        }
    }

    console.log(e1, e2);

    count1 = 0;
    count2 = 0;
    for (let num of nums) {
        if (num === e1) count1++;
        else if (num === e2) count2++;
    }




    let c = Math.floor(nums.length / 3);
    let ans = [];

    if (count1 > c) {
        ans.push(e1);
    }

    if (count2 > c) {
        ans.push(e2);
    }

    return ans;

};



Missing Number:


/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    let n = nums.length;
    let expectedSum = (n * (n + 1)) / 2;
    let actualSum = nums.reduce((a, b) => a + b, 0);
    return expectedSum - actualSum;
};


var missingNumber = function(nums) {
    let n = nums.length;
    let xor = 0;

    for (let i = 0; i <= n; i++) {
        xor ^= i;
    }
    for (let num of nums) {
        xor ^= num;
    }
    return xor;
};




Merge Intervals:


/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    if (intervals.length <= 1) return intervals;

    // Step 1: Sort by start time
    intervals.sort((a, b) => a[0] - b[0]);

    let merged = [intervals[0]];

    // Step 2: Merge overlaps
    for (let i = 1; i < intervals.length; i++) {
        let last = merged[merged.length - 1];
        let current = intervals[i];

        if (current[0] <= last[1]) {
            // Overlap → merge
            last[1] = Math.max(last[1], current[1]);
        } else {
            // No overlap → push new interval
            merged.push(current);
        }
    }

    return merged;
};


/**
 * @param {number[][]} intervals
 * @return {number}
 */
var eraseOverlapIntervals = function (intervals) {

    intervals.sort((a, b) => {

        if (a[0] != b[0]) {
            return a[0] - b[0];
        }
        else {
            return a[1] - b[1];
        }
    });
    let count = 0;
    let prevEnd = intervals[0][1];

    for (let i = 1; i < intervals.length; i++) {

        if (prevEnd > intervals[i][0]) {
            ++count;
            prevEnd = Math.min(prevEnd, intervals[i][1]);
        }
        else {
            prevEnd = intervals[i][1];
        }
    }

    return count;
};



/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function (matrix) {

    let rc = matrix.length;
    let cc = matrix[0].length;
    let isFirstRowZero = false;
    let isFirstColZero = false;

    for (let i = 0; i < rc; i++) {
        if (matrix[i][0] == 0) {
            isFirstColZero = true;
            break;
        }
    }

    for (let i = 0; i < cc; i++) {
        if (matrix[0][i] == 0) {
            isFirstRowZero = true;
            break;
        }
    }

    for (let i = 1; i < rc; i++) {

        for (let j = 1; j < cc; j++) {

            if (matrix[i][j] == 0) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }

    for (let i = 1; i < rc; i++) {
        for (let j = 1; j < cc; j++) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }

    if (isFirstColZero) {
        for (let i = 0; i < rc; i++) {
            matrix[i][0] = 0
        }

    }

    if (isFirstRowZero) {
        for (let i = 0; i < cc; i++) {
            matrix[0][i] = 0
        }

    }
}



Subarray Sum Equals K:

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarraySum = function (nums, k) {

    let map = new Map();
    map.set(0, 1);
    let sum = 0;
    let count = 0;

    for (let num of nums) {

        sum += num;

        if (map.has(sum - k)) {

            count += map.get(sum - k);
        }

        map.set(sum, (map.get(sum) || 0) + 1);
    }
    return count;

};



3Sum:

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {


    nums.sort((a, b) => a - b);
    const ans = [];

    for (let i = 0; i < nums.length - 2; i++) {

        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }

        let left = i + 1;
        let right = nums.length - 1;

        while (left < right) {

            let sum = nums[i] + nums[left] + nums[right];

            if (sum == 0) {

                ans.push([nums[i], nums[left], nums[right]]);
                while (left < right && nums[left] == nums[left + 1]) {
                    ++left;
                }
                while (left < right && nums[right] == nums[right - 1]) {
                    --right;
                }
                ++left;
                --right;
            }
            else if (sum > 0) {

                --right;
            }
            else {
                ++left;
            }
        }
    }
    return ans;
};


Container With Most Water:

/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function (height) {

    let left = 0;
    let right = height.length - 1;
    let ans = -Infinity;

    while (left < right) {

        let cap = (right - left) * Math.min(height[left], height[right]);
        ans = Math.max(ans, cap);

        if (height[left] > height[right]) {
            --right;
        }
        else {
            ++left;
        }
    }

    return ans;

};



Trapping Rain Water:

Solution:

/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function (nums) {


    let left = new Array(nums.length).fill(0);
    let right = new Array(nums.length).fill(0);
    let ans = 0;
    let i = 0;
    left[i] = nums[i];;

    for (let i = 1; i < nums.length; i++) {
        left[i] = Math.max(nums[i], left[i - 1]);
    }
    left[0] = -1;

    right[nums.length - 1] = nums[nums.length - 1];

    for (let i = nums.length - 2; i >= 0; --i) {
        right[i] = Math.max(nums[i], right[i + 1]);
    }

    right[nums.length - 1] = -1

    for (let i = 0; i < nums.length; i++) {
        let c = (Math.min(left[i], right[i]) - nums[i]);
        if (c > 0) {
            ans += c;
        }
    }

    return ans;

};


/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function (nums) {


    let left = 1;
    let right = nums.length - 2;
    let ans = 0;
    let lMax = nums[0];
    let rMax = nums[nums.length - 1];

    while (left <= right) {

        if (rMax > lMax) {

            let cap = (lMax - nums[left]);
            lMax = Math.max(lMax, nums[left]);
            if (cap > 0) {
                ans += cap;
            }
            ++left;
        }
        else {

            let cap = (rMax - nums[right]);
            rMax = Math.max(rMax, nums[right]);
            if (cap > 0) {
                ans += cap;
            }
            --right;
        }
    }



    return ans;


};



Backspace String Compare:

var backspaceCompare = function (s, t) {
    let i = s.length - 1, j = t.length - 1;
    let skipS = 0, skipT = 0;

    while (i >= 0 || j >= 0) {
        // Move i
        while (i >= 0) {
            if (s[i] === '#') { skipS++; i--; }
            else if (skipS > 0) { skipS--; i--; }
            else break;
        }

        // Move j
        while (j >= 0) {
            if (t[j] === '#') { skipT++; j--; }
            else if (skipT > 0) { skipT--; j--; }
            else break;
        }

        let sc = s[i] ? s[i] : null;
        let tc = t[j] ? t[j] : null;

        if (s[i] !== t[j]) {
            return false;
        }
        i--; j--;
    }
    return true;
};




/**
 * @param {string} num
 * @param {number} k
 * @return {string}
 */
var removeKdigits = function (num, k) {


    let stack = [];

    for (let n of num) {

        while (k > 0 && stack.length > 0 && stack[stack.length - 1] > n) {

            stack.pop();
            --k;
        }
        stack.push(n);
    }


    while (k > 0) {
        stack.pop();
        --k;
    }
    while (stack[0] == 0) {

        stack.shift();

    }

    return stack.join('') || '0';
};


/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {


    let seen = new Map();
    let left = 0;
    let ans = 0;

    for (let right = 0; right < s.length; ++right) {

        let c = s[right];

        if (seen.has(c) && seen.get(c) >= left) {
            left = seen.get(c) + 1;
        }

        seen.set(c, right);
        ans = Math.max(ans, right - left + 1);
    }

    return ans;
}



/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var checkInclusion = function (s1, s2) {

    if (s1.length > s2.length) {
        return false;
    }

    let char1 = new Array(26).fill(0);
    let char2 = new Array(26).fill(0);

    let i;

    for (i = 0; i < s1.length; i++) {

        let code1 = s1[i].charCodeAt(0) - 97;
        let code2 = s2[i].charCodeAt(0) - 97;
        ++char1[code1];
        ++char2[code2];
    }

    char1 = char1.join('');

    if (char1 == char2.join('')) {
        return true;
    }

    let j = 0;

    for (i; i < s2.length; i++, j++) {

        let code1 = s2[j].charCodeAt(0) - 97;
        let code2 = s2[i].charCodeAt(0) - 97;
        --char2[code1];
        ++char2[code2];

        if (char1 == char2.join('')) {
            return true;
        }
    }
    return false;
};
