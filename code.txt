Study plan + must‚Äëknow templates (4 weeks, 6 days/week)
Week 1: Arrays, Hashing, Two Pointers, Sliding Window, Stack
Day 1 (Arrays/Hashing): Product of Array Except Self, Longest Consecutive Sequence, Majority Element, Missing Number.
Day 2 (Intervals + Prefix): Merge Intervals, Non-overlapping Intervals, Merge Sorted Array, Set Matrix Zeroes, Subarray Sum Equals K.
Day 3 (Two Pointers): 3Sum, Container With Most Water, Trapping Rain Water, Backspace String Compare, Remove K Digits.
Day 4 (Sliding Window I): Longest Substring Without Repeating Characters, Permutation in String, Find All Anagrams in a String, Sliding Window Maximum.
Day 5 (Sliding Window II): Longest Repeating Character Replacement, Minimum Window Substring, Decode Ways, Sort Colors.
Day 6 (Review/Mocks): Re‚Äëdo misses; 1 mock timed set (4 problems mixed).

Week 2: Linked Lists, Binary Search, Trees (basics), Heaps/Greedy
Day 1 (Linked List I): Reverse Linked List, Merge Two Sorted Lists, Remove Nth Node From End, Reorder List.
Day 2 (Linked List II): Add Two Numbers, Linked List Cycle, Linked List Cycle II, Palindrome Linked List, Intersection of Two Linked Lists, Copy List with Random Pointer.
Day 3 (Binary Search): Binary Search, First Bad Version, Find Peak Element, Search a 2D Matrix, Search in Rotated Sorted Array, Find Minimum in Rotated Sorted Array, Median of Two Sorted Arrays, Koko Eating Bananas.
Day 4 (Trees I): Invert Binary Tree, Maximum Depth(no of nodes from root), Balanced Binary Tree, Diameter of Binary Tree, Binary Tree Level Order Traversal, Right Side View.
Day 5 (Heaps/Greedy/Intervals): Kth Largest Element, Task Scheduler, Car Fleet, Largest Rectangle in Histogram, Merge K Sorted Lists, Find Median from Data Stream.
Day 6 (Review/Mocks): Mixed set; revisit weak topics.

Week 3: Graphs, Union-Find, Backtracking, Tries, Matrix BFS
Day 1 (Graphs BFS/DFS): Number of Islands, Clone Graph(BFS,DFS), Rotting Oranges, Pacific Atlantic Water Flow.
Day 2 (Topo/Ordering): Course Schedule, course-schedule-ii, Alien Dictionary, Graph Valid Tree, Redundant Connection, Network Delay Time(Dijkstra)(TC:O((V + E) log V)), Accounts Merge.
Day 3 (Union-Find): Graph Valid Tree, Redundant Connection, Accounts Merge, Number of Islands (UF variant).
Day 4 (Backtracking): Generate Parentheses, Permutations, Subsets, Combination Sum, Word Search (if in your pool), Word Break.
Day 5 (Trie/Strings): Implement Trie, Add and Search Word, Top K Frequent Words, Encode/Decode Strings.
Day 6 (Review/Mocks): 1 full mock; re‚Äëdo 3 hardest.

Week 4: Dynamic Programming, Advanced Trees, Mixed Review
Day 1 (1D DP): Climbing Stairs, House Robber, House Robber II, Maximum Subarray, Maximum Product Subarray.
Day 2 (Knapsack/Coins): Coin Change, Coin Change II (if in pool), Decode Ways (DP view), Word Break (DP view), Unique Paths.
Day 3 (LIS/Greedy DP): Longest Increasing Subsequence, Russian Doll Envelopes (if in pool), Partition Equal Subset Sum (if in pool).
Day 4 (Tree/Graph DP & Construction): Path Sum, Kth Smallest/Largest in BST, Validate BST, LCA, Build Tree from Preorder+Inorder, Serialize/Deserialize.
Day 5 (Mixed hard review): Minimum Window Substring, Sliding Window Maximum, Median of Two Sorted Arrays, Task Scheduler, Word Ladder.
Day 6 (Final mock + reflections): 1‚Äì2 timed mocks; compile a mistakes log.

Week 5: Gap Coverage + Final Polish
Day 1 (Bit Manipulation + Monotonic Stack):
Single Number, Number of 1 Bits, Counting Bits, Reverse Bits, Daily Temperatures, Next Greater Element I, Next Greater Element II.
Day 2 (Matrix/Grid + Strings):
Shortest Path in Binary Matrix, Surrounded Regions, Spiral Matrix, Rotate Image, Group Anagrams, Valid Palindrome II.
Day 3 (Advanced DP I):
Edit Distance, Longest Common Subsequence, Longest Palindromic Substring, Palindromic Substrings.
Day 4 (Advanced DP II + Trees):
Best Time to Buy and Sell Stock with Cooldown, Same Tree, Subtree of Another Tree, Binary Tree Maximum Path Sum.
Day 5 (Graphs + Hard Problems):
Cheapest Flights Within K Stops(Bellman ford), Swim in Rising Water, Min Cost to Connect All Points (Prim's/Kruskal's), First Missing Positive.
Day 6 (Final Mock + Weak Areas):
2 timed mocks (4 problems each, 2 hours total); revisit 5 hardest problems from entire 5-week plan; update mistakes log.

Week 6: Design Problems, Math, Recursion Mastery + Interview Simulation
Day 1 (Design/OOP Problems):
LRU Cache, LFU Cache, Min Stack (O(1) space), Insert Delete GetRandom O(1), Design HashMap, Design Twitter.
Day 2 (Math & Number Theory):
Pow(x, n), Sqrt(x), Happy Number, Ugly Number II, Count Primes, Multiply Strings, Integer to Roman, Roman to Integer.
Day 3 (Advanced Intervals & Heap Patterns):
Meeting Rooms, Meeting Rooms II, Insert Interval, Minimum Number of Arrows to Burst Balloons, Reorganize String, K Closest Points to Origin, Top K Frequent Elements.
Day 4 (Recursion Mastery + Divide & Conquer):
Merge sort, Letter Combinations of a Phone Number, N-Queens, Sudoku Solver, Different Ways to Add Parentheses, Flatten Nested List Iterator, Power Set (iterative vs recursive).
Day 5 (Commonly Asked Gaps + Hard Strings):
Valid Parentheses (edge cases), Longest Valid Parentheses, Basic Calculator, Basic Calculator II, Integer to English Words, ZigZag Conversion.


/**

Anagram: s2 is angram of s1 if s1 chas jumbled. no addtion, subtraction of chars and lenght of s1 == s2.



**/




/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function (strs) {


    let map = new Map();

    for (let str of strs) {
        let counts = new Array(26).fill(0);

        for (let char of str) {

            let alpha = char.charCodeAt(0) - 97;
            ++counts[alpha];
        }

        counts = counts.join(',');

        if (!map.has(counts)) {
            map.set(counts, []);
        }
        map.get(counts).push(str);
    }

    return Array.from(map.values());
};

//111000// ElevenOn1
//111000// OneEleven




/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function (nums, k) {

    let frequency = new Map();
    for (let num of nums) {

        if (!frequency.has(num)) {
            frequency.set(num, 0);
        }
        frequency.set(num, frequency.get(num) + 1);
    }



    let buckets = new Array(nums.length + 1).fill(null).map(() => []);

    for (let [key, value] of frequency.entries()) {
        buckets[value].push(key);
    }

    let ans = [];

    for (let i = buckets.length - 1; i >= 0 && ans.length < k; --i) {

        for (let num of buckets[i]) {

            if (ans.length >= k) {
                break;
            }
            ans.push(num);
        }
    }
    return ans;

};


/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function (nums) {

    let ans = new Array(nums.length).fill(0);

    let prefix = 1;

    for (let i = 0; i < nums.length; i++) {

        ans[i] = prefix;
        prefix *= nums[i];

    }

    let suffix = 1;

    for (let i = nums.length - 1; i >= 0; i--) {

        ans[i] *= suffix;
        suffix *= nums[i];

    }

    return ans;

};


Longest Consecutive Sequence:

/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function (nums) {

    if (nums.length == 0) {
        return 0;
    }


    let uniqueNums = new Set(nums);
    let max = -Infinity;

    for (let num of uniqueNums) {

        if (uniqueNums.has(num - 1)) {
            continue;
        }

        let count = 0;

        while (uniqueNums.has(num)) {

            ++count;
            ++num;
        }
        max = Math.max(max, count);
    }
    return max;
};


Majority Element:

/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function (nums) {

    let count = 0;
    let c = '';

    for (let num of nums) {

        if (count == 0 || c == num) {
            c = num;
            ++count
        } else {
            --count;
        }
    }
    return c;
};


Majority Element 2:

/**
 * @param {number[]} nums
 * @return {number[]}
 */

var majorityElement = function (nums) {


    let e1 = null;
    let e2 = null;
    let count1 = 0;
    let count2 = 0;

    for (let n of nums) {


        if (e1 === n) {
            ++count1;
        }

        else if (e2 === n) {
            ++count2;
        }

        else if (count1 == 0) {
            e1 = n;
            count1 = 1;
        }
        else if (count2 == 0) {
            e2 = n;
            count2 = 1;
        }
        else {

            --count1;
            --count2;

        }
    }

    console.log(e1, e2);

    count1 = 0;
    count2 = 0;
    for (let num of nums) {
        if (num === e1) count1++;
        else if (num === e2) count2++;
    }




    let c = Math.floor(nums.length / 3);
    let ans = [];

    if (count1 > c) {
        ans.push(e1);
    }

    if (count2 > c) {
        ans.push(e2);
    }

    return ans;

};



Missing Number:


/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    let n = nums.length;
    let expectedSum = (n * (n + 1)) / 2;
    let actualSum = nums.reduce((a, b) => a + b, 0);
    return expectedSum - actualSum;
};


var missingNumber = function(nums) {
    let n = nums.length;
    let xor = 0;

    for (let i = 0; i <= n; i++) {
        xor ^= i;
    }
    for (let num of nums) {
        xor ^= num;
    }
    return xor;
};




Merge Intervals:


/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    if (intervals.length <= 1) return intervals;

    // Step 1: Sort by start time
    intervals.sort((a, b) => a[0] - b[0]);

    let merged = [intervals[0]];

    // Step 2: Merge overlaps
    for (let i = 1; i < intervals.length; i++) {
        let last = merged[merged.length - 1];
        let current = intervals[i];

        if (current[0] <= last[1]) {
            // Overlap ‚Üí merge
            last[1] = Math.max(last[1], current[1]);
        } else {
            // No overlap ‚Üí push new interval
            merged.push(current);
        }
    }

    return merged;
};


/**
 * @param {number[][]} intervals
 * @return {number}
 */
var eraseOverlapIntervals = function (intervals) {

    intervals.sort((a, b) => {

        if (a[0] != b[0]) {
            return a[0] - b[0];
        }
        else {
            return a[1] - b[1];
        }
    });
    let count = 0;
    let prevEnd = intervals[0][1];

    for (let i = 1; i < intervals.length; i++) {

        if (prevEnd > intervals[i][0]) {
            ++count;
            prevEnd = Math.min(prevEnd, intervals[i][1]);
        }
        else {
            prevEnd = intervals[i][1];
        }
    }

    return count;
};



/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function (matrix) {

    let rc = matrix.length;
    let cc = matrix[0].length;
    let isFirstRowZero = false;
    let isFirstColZero = false;

    for (let i = 0; i < rc; i++) {
        if (matrix[i][0] == 0) {
            isFirstColZero = true;
            break;
        }
    }

    for (let i = 0; i < cc; i++) {
        if (matrix[0][i] == 0) {
            isFirstRowZero = true;
            break;
        }
    }

    for (let i = 1; i < rc; i++) {

        for (let j = 1; j < cc; j++) {

            if (matrix[i][j] == 0) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }

    for (let i = 1; i < rc; i++) {
        for (let j = 1; j < cc; j++) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }

    if (isFirstColZero) {
        for (let i = 0; i < rc; i++) {
            matrix[i][0] = 0
        }

    }

    if (isFirstRowZero) {
        for (let i = 0; i < cc; i++) {
            matrix[0][i] = 0
        }

    }
}



Subarray Sum Equals K:

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarraySum = function (nums, k) {

    let map = new Map();
    map.set(0, 1);
    let sum = 0;
    let count = 0;

    for (let num of nums) {

        sum += num;

        if (map.has(sum - k)) {

            count += map.get(sum - k);
        }

        map.set(sum, (map.get(sum) || 0) + 1);
    }
    return count;

};



3Sum:

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {


    nums.sort((a, b) => a - b);
    const ans = [];

    for (let i = 0; i < nums.length - 2; i++) {

        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }

        let left = i + 1;
        let right = nums.length - 1;

        while (left < right) {

            let sum = nums[i] + nums[left] + nums[right];

            if (sum == 0) {

                ans.push([nums[i], nums[left], nums[right]]);
                while (left < right && nums[left] == nums[left + 1]) {
                    ++left;
                }
                while (left < right && nums[right] == nums[right - 1]) {
                    --right;
                }
                ++left;
                --right;
            }
            else if (sum > 0) {

                --right;
            }
            else {
                ++left;
            }
        }
    }
    return ans;
};


Container With Most Water:

/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function (height) {

    let left = 0;
    let right = height.length - 1;
    let ans = -Infinity;

    while (left < right) {

        let cap = (right - left) * Math.min(height[left], height[right]);
        ans = Math.max(ans, cap);

        if (height[left] > height[right]) {
            --right;
        }
        else {
            ++left;
        }
    }

    return ans;

};



Trapping Rain Water:

Solution:

/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function (nums) {


    let left = new Array(nums.length).fill(0);
    let right = new Array(nums.length).fill(0);
    let ans = 0;
    let i = 0;
    left[i] = nums[i];;

    for (let i = 1; i < nums.length; i++) {
        left[i] = Math.max(nums[i], left[i - 1]);
    }
    left[0] = -1;

    right[nums.length - 1] = nums[nums.length - 1];

    for (let i = nums.length - 2; i >= 0; --i) {
        right[i] = Math.max(nums[i], right[i + 1]);
    }

    right[nums.length - 1] = -1

    for (let i = 0; i < nums.length; i++) {
        let c = (Math.min(left[i], right[i]) - nums[i]);
        if (c > 0) {
            ans += c;
        }
    }

    return ans;

};


/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function (nums) {


    let left = 1;
    let right = nums.length - 2;
    let ans = 0;
    let lMax = nums[0];
    let rMax = nums[nums.length - 1];

    while (left <= right) {

        if (rMax > lMax) {

            let cap = (lMax - nums[left]);
            lMax = Math.max(lMax, nums[left]);
            if (cap > 0) {
                ans += cap;
            }
            ++left;
        }
        else {

            let cap = (rMax - nums[right]);
            rMax = Math.max(rMax, nums[right]);
            if (cap > 0) {
                ans += cap;
            }
            --right;
        }
    }



    return ans;


};



Backspace String Compare:

var backspaceCompare = function (s, t) {
    let i = s.length - 1, j = t.length - 1;
    let skipS = 0, skipT = 0;

    while (i >= 0 || j >= 0) {
        // Move i
        while (i >= 0) {
            if (s[i] === '#') { skipS++; i--; }
            else if (skipS > 0) { skipS--; i--; }
            else break;
        }

        // Move j
        while (j >= 0) {
            if (t[j] === '#') { skipT++; j--; }
            else if (skipT > 0) { skipT--; j--; }
            else break;
        }

        let sc = s[i] ? s[i] : null;
        let tc = t[j] ? t[j] : null;

        if (s[i] !== t[j]) {
            return false;
        }
        i--; j--;
    }
    return true;
};




/**
 * @param {string} num
 * @param {number} k
 * @return {string}
 */
var removeKdigits = function (num, k) {


    let stack = [];

    for (let n of num) {

        while (k > 0 && stack.length > 0 && stack[stack.length - 1] > n) {

            stack.pop();
            --k;
        }
        stack.push(n);
    }


    while (k > 0) {
        stack.pop();
        --k;
    }
    while (stack[0] == 0) {

        stack.shift();

    }

    return stack.join('') || '0';
};


/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {


    let seen = new Map();
    let left = 0;
    let ans = 0;

    for (let right = 0; right < s.length; ++right) {

        let c = s[right];

        if (seen.has(c) && seen.get(c) >= left) {
            left = seen.get(c) + 1;
        }

        seen.set(c, right);
        ans = Math.max(ans, right - left + 1);
    }

    return ans;
}



/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var checkInclusion = function (s1, s2) {

    if (s1.length > s2.length) {
        return false;
    }

    let char1 = new Array(26).fill(0);
    let char2 = new Array(26).fill(0);

    let i;

    for (i = 0; i < s1.length; i++) {

        let code1 = s1[i].charCodeAt(0) - 97;
        let code2 = s2[i].charCodeAt(0) - 97;
        ++char1[code1];
        ++char2[code2];
    }

    char1 = char1.join('');

    if (char1 == char2.join('')) {
        return true;
    }

    let j = 0;

    for (i; i < s2.length; i++, j++) {

        let code1 = s2[j].charCodeAt(0) - 97;
        let code2 = s2[i].charCodeAt(0) - 97;
        --char2[code1];
        ++char2[code2];

        if (char1 == char2.join('')) {
            return true;
        }
    }
    return false;
};




/**
 * @param {string} s
 * @param {string} p
 * @return {number[]}
 */
var findAnagrams = function (s, p) {
  if (p.length > s.length) return [];

  const result = [];
  const pCount = new Array(26).fill(0);
  const windowCount = new Array(26).fill(0);

  // store frequency of p
  for (let char of p) {
    pCount[char.charCodeAt(0) - 97]++;
  }

  let left = 0;

  // sliding window over s
  for (let right = 0; right < s.length; right++) {
    windowCount[s.charCodeAt(right) - 97]++;

    // keep window size same as p
    if (right - left + 1 > p.length) {
      windowCount[s.charCodeAt(left) - 97]--;
      left++;
    }

    // compare when window size matches p
    if (right - left + 1 === p.length &&
        pCount.toString() === windowCount.toString()) {
      result.push(left);
    }
  }

  return result;
};



/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var characterReplacement = function (s, k) {

    let left = 0;
    let right = 0;
    let ans = -Infinity;
    let chars = new Array(26).fill(0);
    let maxF = 0;

    while (right < s.length) {

        let code = s[right].charCodeAt(0) - 65;
        ++chars[code];

        maxF = Math.max(maxF, chars[code]);

        let length = right - left + 1;

        if (length > (maxF + k)) {

            code = s[left].charCodeAt(0) - 65;
            --chars[code];
            ++left;
        }
        ans = Math.max(ans, right - left + 1);
        ++right

    }

    return ans;
};



Decode Ways:

/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function (s) {


    let map = new Map();
    let cache = new Map();

    for (let i = 0; i < 26; i++) {
        map.set(`${i + 1}`, String.fromCharCode(65 + i));
    }

    let travel = (i) => {


        if (i < 0) {
            return 1;
        }

        if (cache.has(i)) {
            return cache.get(i);
        }

        let res = 0;

        if (map.has(s[i])) {
            res = travel(i - 1);
        }

        if (map.has(s[i - 1] + s[i])) {
            res += travel(i - 2);
        }

        cache.set(i, res);

        return res;
    }
    return travel(s.length - 1);

};



/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var sortColors = function (nums) {


    let i = 0;
    let left = 0;
    let right = nums.length - 1;

    while (i <= right) {


        if (nums[i] == 0) {
            [nums[left], nums[i]] = [nums[i], nums[left]];
            ++left;
            ++i; // incrementing as at pos left 2 never comes as it already moved to right pos.
        }

        else if (nums[i] == 2) {
            [nums[right], nums[i]] = [nums[i], nums[right]];
            --right;
        }
        else {
            ++i;
        }
    }
    return nums;
}



/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function (nums, k) {

    let t = [];
    let ans = [];
    k = k - 1;

    for (let i = 0; i < nums.length; i++) {

        if (t.length && (i - k) > t[0]) {
            t.shift();
        }

        while (t.length && nums[i] >= nums[t[t.length - 1]]) {
            t.pop();
        }

        t.push(i);

        if (i >= k) {
            ans.push(nums[t[0]]);
        }
    }

    return ans;
};



/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function (s, t) {

    const map1 = new Map();
    const map2 = new Map();
    let left = 0;
    let ans = '';

    for (let c of t) {
        map1.set(c, (map1.get(c) || 0) + 1);
    }

    let req = map1.size;
    let have = 0;

    for (let right = 0; right < s.length; ++right) {

        let c = s[right];

        map2.set(c, (map2.get(c) || 0) + 1);

        if (map2.get(c) == map1.get(c)) {
            ++have;
        }

        if (req == have) {

            let start = left;

            while (left <= right) {

                let c = s[left];
                start = left;

                map2.set(c, map2.get(c) - 1);

                if (map1.get(c) > map2.get(c)) {
                    --have;
                    ++left;
                    break;
                }

                ++left;
            }

            if (!ans || ans.length > (right - left + 1)) {
                ans = s.substring(start, right + 1);
            }

        }
    }

    return ans;

};


Reverse Linked List:

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {

    let travel = (p, q) => {

        if (!p) {
            return q;
        }
        let r = p.next;
        p.next = q;
        q = p;

        return travel(r, q);
    }

    return travel(head, null)


};


Merge Two Sorted Lists:

/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function (list1, list2) {

    let head = new ListNode(0, null);
    let temp = head;
    
    while (list1 && list2) {

        if (list1.val >= list2.val) {

            temp.next = list2;
            list2 = list2.next;
        }
        else {
            temp.next = list1;
            list1 = list1.next;
        }

        temp = temp.next;

    }

    if (!list1) {
        temp.next = list2;
    }
    else {
        temp.next = list1;
    }
    return head.next;


};


 Remove Nth Node From End:


/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {

    let s = new ListNode(0, null);
    f = s;
    s.next = head;
    head=s;

    let i = 0;;
    while (i < n) {
        f = f.next;
        ++i;
    }

    while (f.next) {
        f = f.next;
        s = s.next;
    }

    s.next=s.next.next;
    return head.next;

};

Reorder List:

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {void} Do not return anything, modify head in-place instead.
 */
var reorderList = function (head) {

    let reverse = (head) => {
        let p = head;
        let q = null;
        while (p) {
            let r = p.next;
            p.next = q;
            q = p;
            p = r;
        }
        return q;
    }
    
    let slow = head;
    let fast = head;

    while (fast && fast.next && fast.next.next) {
        slow = slow.next;
        fast = fast.next.next;
    }

    let l2 = slow.next;
    let l1 = head;
    slow.next = null;
    l2 = reverse(l2);

    while (l1 && l2) {
        let p = l1.next;
        let q = l2.next;
        l1.next = l2;
        l2.next = p;
        l1 = p;
        l2 = q;
    }
    return head;
};



Linked List Cycle II:


/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var detectCycle = function (head) {

    let slow = head;
    let fast = head;

    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;

        if (slow == fast) {
            slow = head;
            while (slow != fast) {
                slow = slow.next;
                fast = fast.next;
            }
            return slow;
        }
    }
    return null;
};


// Sure üëç here‚Äôs the 4-line explanation of the formula L + x = kC:

// Let L = distance from head to cycle start, x = distance from cycle start to meeting point, C = cycle length.

// At meeting, slow has traveled L + x.

// Fast has traveled L + x + kC (same path as slow + k full cycles).

// Since fast moves twice as fast: L + x + kC = 2(L + x) ‚Üí L + x = kC.

// Would you like me to also give you a one-liner intuition (non-mathy) you can remember easily?



Intersection of Two Linked Lists:

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function (headA, headB) {

    let a = headA;
    let b = headB;

    while (a || b) {

        if (a == null) {
            a = headB
        }
        if (b == null) {
            b = headA;
        }

        if (a == b) {
            return a;
        }
        
        a = a.next;
        b = b.next;

    }
};


/**
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function (nums) {

    nums.unshift(-Infinity);
    nums.push(-Infinity);

    let beg = 1;
    let end = nums.length - 2;

    while (beg <= end) {

        let mid = Math.floor((beg + end) / 2);

        if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {
            return mid - 1;
        }

        if (nums[mid + 1] > nums[mid]) {
            beg = mid + 1;
        }
        else {
            end = mid - 1;
        }
    }
};

/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function (matrix, target) {

    let row = matrix.length;
    let col = matrix[0].length;
    let beg = 0;
    let end = row * col - 1;

    while (beg <= end) {

        let mid = (beg + end) >> 1;

        let i = Math.floor(mid / col);
        let j = mid % col;

        if(matrix[i][j]==target){
            return true;
        }
        else if(matrix[i][j]>target){
            end=mid-1;
        }
        else{
            beg=mid+1;
        }
    }
    return false;

};


Search in Rotated Sorted Array:

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function (nums, target) {


    let beg = 0;
    let end = nums.length - 1;

    while (beg <= end) {

        let mid = (beg + end) >> 1;

        if (nums[mid] == target) {
            return mid;
        }
        else if (nums[mid] >= nums[beg]) {

            if (target >= nums[beg] && target < nums[mid]) {

                end = mid - 1;
            }
            else {
                beg = mid + 1;
            }
        }
        else {

            if (target > nums[mid] && target <= nums[end]) {

                beg = mid + 1;
            }
            else {
                end = mid - 1;
            }
        }
    }

    return -1;
};


Find Minimum in Rotated Sorted Array:


/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var findMin = function (nums) {

    let beg = 0;
    let end = nums.length - 1;
    let min = Infinity;


    while (beg <= end) {

        let mid = (beg + end) >> 1;

        if (nums[mid] >= nums[beg]) {

            min = Math.min(min, nums[beg]);
            beg = mid + 1;
        }
        else {
            min = Math.min(min, nums[end]);
            end = mid - 1;
        }
    }

    return min;
};


Koko Eating Bananas:

/**
 * @param {number[]} piles
 * @param {number} h
 * @return {number}
 */
var minEatingSpeed = function (piles, h) {

    const canEatAll = (k) => {

        let count = 0;

        for (let pile of piles) {

            count += (Math.ceil(pile / k));
            if (count > h) {
                return false;
            }
        }
        return true;
    }

    let left = 0;
    let right = Math.max(...piles);
    let ans = Infinity;

    while (left <= right) {

        let mid = (left + right) >> 1;

        if (canEatAll(mid)) {

            ans = Math.min(ans, mid);
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
    }
    return ans;

};


Invert Binary Tree:

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function (root) {


    let travel = (root) => {

        if (!root) {
            return root;
        }

        let left = root.left;
        root.left = root.right;
        root.right = left;

        travel(root.left);
        travel(root.right);
        return root;
    }

    return travel(root)

};



Maximum Depth:

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {


    let depth = (root) => {

        if (!root) {
            return 0;
        }

        let left = 1 + depth(root.left);
        let right = 1 + depth(root.right);

        return Math.max(left,right);
    }

    return depth(root);


}



Balanced Binary Tree:


/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var isBalanced = function (root) {


    let travel = (root) => {

        if (!root) {
            return 0;
        }

        let left = 1 + travel(root.left);
        let right = 1 + travel(root.right);

        if (Math.abs(left - right) > 1) {
            return Infinity;
        }

        return Math.max(left, right);

    }
    return travel(root) == Infinity ? false : true;

};


//Diameter of Binary Tree


/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function (root) {

    let max = -Infinity;

    let travel = (root) => {

        if (!root) {
            return 0;
        }
        let left = 0;

        if (root.left) {
            left = 1 + travel(root.left);
        }

        let right = 0;

        if (root.right) {
            right = 1 + travel(root.right);
        }

        max = Math.max(max, left + right);
        return Math.max(left, right);
    }

    travel(root);
    return max;
};



//Binary Tree Level Order Traversal

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function (root) {

    if (!root) {
        return [];
    }

    let ans = [];

    let queue = [root];

    while (queue.length > 0) {

        let t = [];
        let i = queue.length;

        while (i > 0) {

            let node = queue.shift();
            t.push(node.val);
            if (node.left) {
                queue.push(node.left);
            }
            if (node.right) {
                queue.push(node.right);
            }
            --i;

        }
        ans.push(t);
    }
    return ans;

};


//Right Side View

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function (root) {

    if (!root) {
        return [];
    }

    let queue = [root];
    let ans = [];

    while (queue.length > 0) {

        let size = queue.length;

        for (let i = 0; i < size; i++) {

            let node = queue.shift();

            if (i == size - 1) {
                ans.push(node.val);
            }

            if (node.left) {
                queue.push(node.left);
            }
            if (node.right) {
                queue.push(node.right);
            }
        }
    }
    return ans;
};


//Kth Largest Element


var findKthLargest = function (nums, k) {

    const heap = [];

    const build = (i) => {

        heap.push(nums[i]);
        i = heap.length - 1;
        let p = Math.floor((i - 1) / 2);
        while (p >= 0 && heap[i] > heap[p]) {
            [heap[i], heap[p]] = [heap[p], heap[i]];
            i = p;
            p = Math.floor((i - 1) / 2);
        }
    }

    const heapifyDown = () => {

        let n = heap.length - 1;
        [heap[0], heap[n]] = [heap[n], heap[0]];
        let e = heap.pop();

        let root = 0;
        let p = 0;

        while (true) {

            let left = 2 * root + 1;
            let right = 2 * root + 2;

            if (left <= n && heap[left] > heap[p]) {
                p = left;
            }

            if (right <= n && heap[right] > heap[p]) {
                p = right;
            }
            if (root == p) {
                break;
            }

            [heap[root], heap[p]] = [heap[p], heap[root]];
            root = p;
        }
        return e;
    }

    for (let i = 0; i < nums.length; i++) {
        build(i);
    }

    let ans = -1;

    for (let i = 0; i < k; i++) {
        ans = heapifyDown();
    }
    return ans;

};



carFleet:

/**
 * @param {number} target
 * @param {number[]} position
 * @param {number[]} speed
 * @return {number}
 */
var carFleet = function (target, position, speed) {


    let cars = [];
    let maxTime = 0;
    let count = 0;

    for (let i = 0; i < position.length; i++) {
        let time = (target - position[i]) / speed[i];
        cars.push([position[i], time]);
    }
    cars.sort((a, b) => b[0] - a[0]);

    for (let car of cars) {

        if (car[1] > maxTime) {
            ++count;
            maxTime = car[1];
        }
    }
    return count;


};


//Task Scheduler

/**
 * @param {character[]} tasks
 * @param {number} n
 * @return {number}
 */
var leastInterval = function (tasks, n) {

    let map = new Map();

    for (let task of tasks) {

        if (!map.has(task)) {
            map.set(task, 0);
        }
        map.set(task, map.get(task) + 1);
    }

    let time = 0;
    let heap = [...map.values()];
    let cooldown = [];


    while (heap.length > 0 || cooldown.length > 0) {

        ++time;
        heap.sort((a, b) => b - a);

        if (heap.length > 0) {

            let job = heap.shift() - 1;
            if (job > 0) {
                cooldown.push([time + n, job]);
            }
        }
        if (cooldown.length > 0 && cooldown[0][0] == time) {
            heap.push(cooldown[0][1]);
            cooldown.shift();
        }
    }
    return time;

};



//Largest Rectangle in Histogram

/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function (heights) {


    heights.unshift(-Infinity);
    heights.push(-Infinity);

    let left = new Array(heights.length).fill(0);
    let right = new Array(heights.length).fill(0);
    let stk = [];

    for (let i = 0; i < heights.length - 1; i++) {

        if (stk.length == 0) {
            stk.push(i);
            continue;
        }

        while (stk.length > 0 && heights[stk[stk.length - 1]] >= heights[i]) {
            stk.pop();
        }

        left[i] = stk[stk.length - 1];

        stk.push(i);
    }

    stk = [];
    for (let i = heights.length - 1; i > 0; i--) {


        if (stk.length == 0) {
            stk.push(i);
            continue;
        }

        while (stk.length > 0 && heights[stk[stk.length - 1]] >= heights[i]) {
            stk.pop();
        }

        right[i] = stk[stk.length - 1];


        stk.push(i);
    }

    //console.log(left, right);


    let max = -Infinity;

    for (let i = 1; i < heights.length - 1; i++) {

        let w = right[i] - left[i] - 1;

        max = Math.max(max, w * heights[i]);
    }
    return max;

};



// merge-k-sorted-lists


/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function (lists) {

    const heap = [];
    const dummy = new ListNode();
    let head = dummy;

    const heapifyUp = (e) => {
        if (!e) {
            return;
        }


        heap.push(e);

        let n = heap.length - 1;
        let p = Math.floor((n - 1) / 2);
        while (p >= 0 && heap[n].val < heap[p].val) {
            [heap[p], heap[n]] = [heap[n], heap[p]];
            n = p;
            p = Math.floor((n - 1) / 2);
        }
    }

    const heapifyDown = () => {

        let node = heap[0];
        let nextNode = node.next;
        node.next = null;

        if (nextNode) {
            heap[0] = nextNode;
        }
        else {
            heap[0] = heap[heap.length - 1];
            heap.pop();
        }

        let n = heap.length - 1;
        let parent = 0;
        let current = 0;

        while (true) {

            let left = 2 * current + 1;
            let right = 2 * current + 2;

            if (left <= n && heap[left].val < heap[current].val) {
                current = left;
            }

            if (right <= n && heap[right].val < heap[current].val) {
                current = right;
            }

            if (parent == current) {
                break;
            }

            [heap[parent], heap[current]] = [heap[current], heap[parent]];

            parent = current;
        }
        return node;
    }

    for (let list of lists) {

        heapifyUp(list);
    }
    //console.log(heap);

    while (heap.length > 0) {
        head.next = heapifyDown();
        head = head.next;
        //console.log(head.val, heap)
    }

    return dummy.next;

};




//Find Median from Data Stream
//For every insertion move max from left to right and min from right to left.

let left = [];
let right = [];

let leftPush = function (num) {

    left.push(num);
    let n = left.length - 1;
    let i = Math.floor((n - 1) / 2);
    while (i >= 0 && left[n] > left[i]) {

        [left[i], left[n]] = [left[n], left[i]];
        n = i;
        i = Math.floor((n - 1) / 2);
    }
}

let rightPush = function (num) {

    right.push(num);
    let n = right.length - 1;
    let i = Math.floor((n - 1) / 2);
    while (i >= 0 && right[n] < right[i]) {

        [right[i], right[n]] = [right[n], right[i]];
        n = i;
        i = Math.floor((n - 1) / 2);
    }
}

let leftDown = function () {

    let current = 0;
    let root = 0;
    let n = left.length;
    while (true) {

        let i = 2 * current + 1; //left child
        let j = 2 * current + 2; // right child

        if (i < n && left[i] > left[current]) {
            current = i;
        }
        if (j < n && left[j] > left[current]) {
            current = j;
        }

        if (current == root) {
            break;
        }
        [left[current], left[root]] = [left[root], left[current]];
        root = current;

    }
}

let rightDown = function () {
    let current = 0;
    let root = 0;
    let n = left.length;
    while (true) {

        let i = 2 * current + 1; //left child
        let j = 2 * current + 2; // right child

        if (i < n && right[i] < right[current]) {
            current = i;
        }
        if (j < n && right[j] < right[current]) {
            current = j;
        }
        if (current == root) {
            break;
        }
        [right[current], right[root]] = [right[root], right[current]];
        root = current;
    }
}

var MedianFinder = function () {
    left = [];
    right = [];
};
/** 
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function (num) {

    leftPush(num);
    let e = left[0];
    left[0] = left[left.length - 1];
    left.pop();
    leftDown();
    rightPush(e);
    if (right.length > left.length) {

        //console.log(left, right)

        let e = right[0];
        right[0] = right[right.length - 1];
        right.pop();
        rightDown();
        leftPush(e);
    }
};

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function () {

    if ((left.length + right.length) % 2 == 0) {

        return (left[0] + right[0]) / 2;
    }
    else {
        return left[0];
    }
};

/** 
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */



//Number of Islands

/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function (grid) {

    let rows = grid.length;
    let cols = grid[0].length;

    let count = 0;

    let travel = (i, j) => {

        if (i < 0 || j < 0 || i >= rows || j >= cols || grid[i][j] == "0") {
            return;
        }

        grid[i][j] = "0";
        travel(i + 1, j);
        travel(i - 1, j);
        travel(i, j + 1);
        travel(i, j - 1);

    }

    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {

            if (grid[i][j] == "1") {

                ++count;
                travel(i, j);
            }
        }
    }

    return count;

};


/**
 * // Definition for a _Node.
 * function _Node(val, neighbors) {
 *    this.val = val === undefined ? 0 : val;
 *    this.neighbors = neighbors === undefined ? [] : neighbors;
 * };
 */

/**
 * @param {_Node} node
 * @return {_Node}
 */
var cloneGraph = function (node) {

    if (!node) {
        return node;
    }

    let nc = new _Node();
    let vis = new Map();

    console.log(node);

    let travel = (nc, node) => {

        //console.log(nc, node)

        if (vis.has(node.val)) {
            return vis.get(node.val);
        }

        vis.set(node.val,nc);

        nc.val = node.val;

        for (let nbr of node.neighbors) {

            let n1 = new _Node();
            nc.neighbors.push(travel(n1, nbr));
            
        }
        return nc;
    }
    let ans=travel(nc, node);

    console.log(ans);
    return ans;
};


//Rotting Oranges

/**
 * @param {number[][]} grid
 * @return {number}
 */
var orangesRotting = function (grid) {

    let count = 0;
    let queue = [];
    let m = grid.length;
    let n = grid[0].length;

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {

            if (grid[i][j] == 2) {
                queue.push([i, j]);

            }
        }
    }
    //console.log(queue)

    while (queue.length > 0) {

        let t = [];
        for (let node of queue) {

            let [i, j] = node;


            if ((i - 1) >= 0) {

                if (grid[i - 1][j] == 1) {

                    grid[i - 1][j] = 2;
                    t.push([i - 1, j])
                }
            }
            if ((i + 1) < m) {

                if (grid[i + 1][j] == 1) {

                    grid[i + 1][j] = 2;

                    t.push([i + 1, j])
                }
            }

            if ((j - 1) >= 0) {
                if (grid[i][j - 1] == 1) {

                    grid[i][j - 1] = 2;
                    t.push([i, j - 1])
                }
            }
            if ((j + 1) < n) {

                if (grid[i][j + 1] == 1) {

                    grid[i][j + 1] = 2;
                    t.push([i, j + 1])
                }
            }
        }
        queue = t;
        if (queue.length > 0) {
            ++count;
        }

    }

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {

            if (grid[i][j] == 1) {
                return -1;

            }
        }
    }

    return count;

};

//console.log(orangesRotting([[1,2]]))


//Pacific Atlantic Water Flow

/**
 * @param {number[][]} heights
 * @return {number[][]}
 */
var pacificAtlantic = function (heights) {


    let rows = heights.length;
    let cols = heights[0].length;
    let ans = [];
    let pacific = [];
    let atlantic = [];

    for (let i = 0; i < rows; i++) {

        pacific.push(new Array(cols).fill(false));
        atlantic.push(new Array(cols).fill(false));
    }

    let travel = (row, col, vis, pHeight) => {

        if (row < 0 || col < 0 || row >= rows || col >= cols
            || vis[row][col] || pHeight > heights[row][col]) {
            return;
        }
        vis[row][col] = true;
        travel(row + 1, col, vis, heights[row][col]);
        travel(row - 1, col, vis, heights[row][col]);
        travel(row, col + 1, vis, heights[row][col]);
        travel(row, col - 1, vis, heights[row][col]);


    }

    for (let i = 0; i < rows; i++) {
        travel(i, 0, pacific, -Infinity)
        travel(i, cols - 1, atlantic, -Infinity)
    }

    for (let i = 0; i < cols; i++) {
        travel(0, i, pacific, -Infinity)
        travel(rows - 1, i, atlantic, -Infinity)
    }

    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (pacific[i][j] && atlantic[i][j]) {
                ans.push([i, j]);
            }
        }
    }
    return ans;
};


//Course Schedule 1

/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
var canFinish = function (numCourses, prerequisites) {

    const g = new Map();
    const visited = new Array(numCourses).fill(false);
    const inStack = new Array(numCourses).fill(false);

    for (let [v, u] of prerequisites) {

        if (!g.has(u)) {
            g.set(u, []);
        }

        g.get(u).push(v);
    }

    let dfs = (start) => {

        // if (inStack[start]) {
        //     return true;
        // }

        if (visited[start]) {
            return true;
        }


        visited[start] = true;
        //inStack[start] = true;

        const nbrs = g.get(start) || [];

        for (const nbr of nbrs) {

            if (dfs(nbr)) {
                return true;
            }

        }
        //inStack[start] = false;
        return false;
    }

    for (let i = 0; i < numCourses; i++) {
        if (!visited[i] && dfs(i)) {
            return false;
        }
    }
    return true;

};

// Find cycle exists or not.

//Course Schedule 2


/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
var findOrder = function (numCourses, prerequisites) {

    let g = new Map();
    let ans = [];

    for (let [u, v] of prerequisites) {

        if (!g.has(v)) {
            g.set(v, []);
        }
        g.get(v).push(u);
    }

    let vis = new Map();
    let stateMap = new Map();

    let isCycle = (i) => {

        if (stateMap.has(i)) {
            return true;
        }

        if (vis.has(i)) {
            return false;
        }

        vis.set(i, true);
        stateMap.set(i, true);

        let nbrs = g.get(i) || [];

        for (let nbr of nbrs) {

            let res = isCycle(nbr);
            if (res) {
                return res;
            }
        }
        stateMap.delete(i);
        ans.push(i);
        return false;
    }

    for (let i = 0; i < numCourses; i++) {
        let res = isCycle(i);
        if (res) {
            return [];
        }
    }
    return ans.reverse();
};


//Graph Valid Tree

class Solution {
    // Function to check whether the given graph is a tree or not.
    isTree(n, adj) {
        let edges = [];
        let map = new Map();

        // collect unique edges
        for (let i = 0; i < n; i++) {
            let nbrs = adj[i] || [];
            for (let nbr of nbrs) {
                let key1 = `${i}_${nbr}`;
                let key2 = `${nbr}_${i}`;
                if (!map.has(key1) && !map.has(key2)) {
                    map.set(key1, true);
                    edges.push([i, nbr]);
                }
            }
        }

        // check edge count
        if (edges.length !== n - 1) return 0;

        let p = new Array(n).fill(0).map((_, i) => i);

        let getParent = (u) => {
            if (p[u] !== u) p[u] = getParent(p[u]);
            return p[u];
        };

        let merge = (u, v) => {
            let pu = getParent(u);
            let pv = getParent(v);
            if (pu === pv) return false; // cycle
            p[pv] = pu; // ‚úÖ correct union
            return true;
        };

        // check for cycles
        for (let [u, v] of edges) {
            if (!merge(u, v)) return 0;
        }

        // ensure connected (only 1 component)
        let count = 0;
        for (let i = 0; i < n; i++) {
            if (p[i] === i) count++;
        }
        return count === 1 ? 1 : 0;
    }
}



//Alien Dictionary

class Solution {
    findOrder(words) {
        let graph = new Map();
        let chars = new Set();

        // Collect all characters
        for (let word of words) {
            for (let ch of word) {
                let code = ch.charCodeAt(0) - 'a'.charCodeAt(0);
                chars.add(code);
                if (!graph.has(code)) {
                    graph.set(code, []);
                }
            }
        }

        // Build graph
        for (let i = 0; i < words.length - 1; i++) {
            let w1 = words[i];
            let w2 = words[i + 1];
            let minLen = Math.min(w1.length, w2.length);

            let j = 0;
            for (; j < minLen; j++) {
                if (w1[j] !== w2[j]) {
                    let u = w1[j].charCodeAt(0) - 'a'.charCodeAt(0);
                    let v = w2[j].charCodeAt(0) - 'a'.charCodeAt(0);
                    graph.get(u).push(v);
                    break;
                }
            }
            // Handle prefix edge case: if all characters matched but first word is longer
            if (j === minLen && w1.length > w2.length) {
                return "";
            }
        }

        let visited = Array(26).fill(false);
        let inStack = Array(26).fill(false);
        let result = [];
        let hasCycle = false;

        const dfs = (node) => {
            if (inStack[node]) return false; // Cycle detected
            if (visited[node]) return true;

            visited[node] = true;
            inStack[node] = true;

            for (let neighbor of graph.get(node) || []) {
                if (!dfs(neighbor)) return false;
            }

            inStack[node] = false;
            result.push(String.fromCharCode(node + 'a'.charCodeAt(0)));
            return true;
        };

        for (let ch of chars) {
            if (!visited[ch]) {
                if (!dfs(ch)) return ""; // cycle found, invalid order
            }
        }

        return result.reverse().join('');
    }
}




//Redundant Connection:

/**
 * @param {number[][]} edges
 * @return {number[]}
 */
var findRedundantConnection = function (edges) {

    let vertices = new Set();
    const ans = [];

    for (let [u, v] of edges) {

        vertices.add(u);
        vertices.add(v);

    }

    let p = new Array(vertices.size + 1).fill(0).map((v, i) => i);
    let size = new Array(vertices.size + 1).fill(0);



    let getParent = (u) => {

        if (p[u] != u) {

            p[u] = getParent(p[u]);
        }
        return p[u];
    }

    let merge = (u, v) => {

        let pu = getParent(u);
        let pv = getParent(v);

        if (pu == pv) {
            return false;
        }

        if (size[pu] >= size[pv]) {
            p[pv] = pu;
            ++size[pu];
        }
        else {
            p[pu] = p[pv];
            ++size[pv];
        }

        return true;


    }

    for (let [u, v] of edges) {

        let res = merge(u, v);

        if (!res) {

            ans.push([u, v]);
        }
    }
    return ans[ans.length - 1];
};



//Network Delay(Djekstra)

/**
 * @param {number[][]} times
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var networkDelayTime = function (times, n, k) {


    const dis = new Array(n + 1).fill(Infinity);
    const g = new Map();

    for (let [u, v, w] of times) {

        if (!g.has(u)) {

            g.set(u, []);

        }
        if (!g.has(v)) {
            g.set(v, []);
        }
        g.get(u).push([v, w]);
    }


    dis[k] = 0;


    const queue = [[k, 0]];

    while (queue.length > 0) {

        queue.sort((a, b) => a - b);
        let [u, w1] = queue.shift();

        if (w1 > dis[u]) {
            continue;
        }

        let adj = g.get(u) || [];

        for (let [v, w2] of adj) {

            let cost = w1 + w2;

            if (dis[v] > cost) {
                dis[v] = cost;
                queue.push([v, cost]);
            }
        }
    }

    dis.shift();


    return Math.max(...dis) == Infinity ? -1 : Math.max(...dis);

};

//Network Delay

/**
 * @param {number[][]} times
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var networkDelayTime = function (times, n, k) {


    let dis = new Array(n + 1).fill(Infinity);
    dis[k] = 0;

    for (let i = 1; i < n; i++) {


        let isUpdated = false;
        let t = [...dis];

        for (let [u, v, w] of times) {

            if (dis[u] != Infinity) {

                t[v] = Math.min(t[v], dis[u] + w);
                isUpdated = true;
            }
        }

        dis=t;


        if (!isUpdated) {
            break;
        }
    }
    dis.shift();

    let max = Math.max(...dis);

    return max == Infinity ? -1 : max;

};


//Generate Parentheses,


/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function (n) {



    let ans = [];

    let travel = (s, open, close) => {

        if ((close + open) == 2 * n) {
            ans.push(s);
            return;
        }

        if (open < n) {
            travel(s + "(", open + 1, close);
        }

        if (close < open) {
            travel(s + ")", open, close + 1);
        }


    }

    travel("", 0, 0);

    return ans;

};



//Permutations

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function (nums) {


    let ans = [];
    let n = nums.length;
    let map = new Map();

    const travel = (t) => {


        if (t.length == nums.length) {
            ans.push([...t]);
        }

        for (let i = 0; i < n; i++) {

            if (map.has(i)) {
                continue;
            }

            map.set(i, true);
            t.push(nums[i]);
            travel(t);
            map.delete(i);
            t.pop();
        }
    }

    travel([]);

    return ans;

};


//permute(['a', 'b', 'c'])


//Subsets

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function (nums) {

    let ans = [];

    let travel = (i, t) => {

        if (i == nums.length) {
            ans.push([...t]);
            return;
        }
        travel(i + 1, t);
        t.push(nums[i]);
        travel(i + 1, t);

        t.pop();
    }
    travel(0, []);

    return ans;
};


/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function (candidates, target) {
    let ans = [];
    let map = new Map();

    let travel = (i, t, sum) => {

        if (sum == 0 && !map.has(t.join(','))) {
            ans.push([...t]);
            map.set(t.join(','))
        }
        if (sum < 0 || i == candidates.length) {
            return;
        }

        travel(i + 1, t, sum);
        t.push(candidates[i]);
        travel(i, t, sum - candidates[i]);
        t.pop();
    }

    travel(0, [], target);


    return ans;
};

//Word Search

/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function (board, word) {

    let m = board.length;
    let n = board[0].length;

    let travel = (i, j, str) => {


        if (str == word) {
            return true;
        }

        if (str[str.length - 1] != word[str.length - 1]) {
            return false;
        }

        let char = board[i][j];
        board[i][j] = '#';

        let dirs = [
            [-1, 0],
            [1, 0],
            [0, -1],
            [0, 1]
        ];

        for (let [dx, dy] of dirs) {

            let x = i + dx;
            let y = j + dy;

            if (x < 0 || y < 0 || x >= m || y >= n || board[x][y] == '#') {
                continue;
            }

            let isMatchFound = travel(x, y, str + board[x][y]);
            if (isMatchFound) {
                return isMatchFound;
            }
        }

        board[i][j] = char;
        return false;
    }

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {

            let isMatchFound = travel(i, j, board[i][j]);
            if (isMatchFound) {
                return isMatchFound;
            }
        }
    }




    return false;
};


// Number of Islands  ==> BFS
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function (grid) {

    let count = 0;
    let rows = grid.length;
    let cols = grid[0].length;

    let travel = (i, j) => {

        let queue = [[i, j]];

        while (queue.length > 0) {

            let n = queue.length;

            for (let k = 0; k < n; k++) {

                let [i, j] = queue.shift();

                if ((i + 1) < rows && grid[i + 1][j] == 1) {
                    grid[i + 1][j] = 0;
                    queue.push([i + 1, j]);
                }
                if ((i - 1) < 0 && grid[i - 1][j] == 1) {
                    grid[i - 1][j] = 0;
                    queue.push([i - 1, j]);
                }
                if ((j + 1) < cols && grid[i][j + 1] == 1) {
                    grid[i][j + 1] = 0;
                    queue.push([i, j + 1]);
                }
                if ((j - 1) < 0 && grid[i][j - 1] == 1) {
                    grid[i][j - 1] = 0;
                    queue.push([i, j - 1]);
                }


            }
        }
    }

    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (grid[i][j] == 1) {
                ++count;
                travel(i, j);
            }
        }
    }
    return count;
};

/*
TC: 
m*n
SC:
m*n for grid
m*n for stack


*/

// Number of Islands.  DFS:

/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function (grid) {

    let count = 0;
    let rows = grid.length;
    let cols = grid[0].length;

    let travel = (i, j) => {

        if (i >= rows || i < 0 || j >= cols || j < 0 || grid[i][j] == 0) {
            return
        }

        grid[i][j] = 0;

        travel(i - 1, j);
        travel(i + 1, j);
        travel(i, j + 1);
        travel(i, j - 1);
    }

    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (grid[i][j] == 1) {
                ++count;
                travel(i, j);
            }
        }
    }
    return count;
};


// Implement try



var Trie = function () {
    this.chars = new Array(26).fill(null);
    this.isEnd = false;

};

/** 
 * @param {string} word
 * @return {void}
 */
Trie.prototype.insert = function (word) {

    let node = this;

    for (let c of word) {

        let code = c.charCodeAt(0) - 97;
        if (node.chars[code]) {
            node = node.chars[code];
        }
        else {
            node.chars[code] = new Trie();
            node = node.chars[code];
        }
    }
    node.isEnd = true;

};

/** 
 * @param {string} word
 * @return {boolean}
 */
Trie.prototype.search = function (word) {

    let node = this;

    for (let c of word) {

        let code = c.charCodeAt(0) - 97;
        if (node.chars[code]) {
            node = node.chars[code];
        }
        else {
            return false;
        }
    }
    if (node.isEnd) {
        return true;
    }
    return false;
};

/** 
 * @param {string} prefix
 * @return {boolean}
 */
Trie.prototype.startsWith = function (prefix) {
    let node = this;
    for (let c of prefix) {

        let code = c.charCodeAt(0) - 97;
        if (node.chars[code]) {
            node = node.chars[code];
        }
        else {
            return false;
        }
    }
    return true;

};

/** 
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */


// Add and Search Word


var WordDictionary = function () {

    this.children = new Map();
    this.end = false;

};

/** 
 * @param {string} word
 * @return {void}
 */
WordDictionary.prototype.addWord = function (word) {

    let node = this;

    for (let c of word) {

        if (node.children.has(c)) {
            node = node.children.get(c);
        }
        else {
            let child = new WordDictionary();
            node.children.set(c, child);
            node = child;
        }
    }
    node.end = true;

};

/** 
 * @param {string} word
 * @return {boolean}
 */
WordDictionary.prototype.search = function (word, node = null) {

    if (!node) {
        node = this;
    }

    for (let i = 0; i < word.length; i++) {
        let c = word[i];

        if (node.children.has(c)) {
            node = node.children.get(c);
        }
        else {
            if (c == ".") {

                let newWord = word.substring(i + 1);

                for (let i = 0; i < 26; i++) {

                    let char = String.fromCharCode(97 + i);
                    if (node.children.has(char)) {
                        let res = this.search(newWord, node.children.get(char));
                        if (res) {
                            return true;
                        }
                    }
                }
                return false;
            }
            else {
                return false;
            }
        }
    }
    if (node.end) {
        return true;
    }
    else {
        return false;
    }

};

/** 
 * Your WordDictionary object will be instantiated and called as such:
 * var obj = new WordDictionary()
 * obj.addWord(word)
 * var param_2 = obj.search(word)
 */


//Top K Frequent Words

/**
 * @param {string[]} words
 * @param {number} k
 * @return {string[]}
 */
var topKFrequent = function (words, k) {

    let map = new Map();

    for (let word of words) {

        if (!map.has(word)) {
            map.set(word, 0);
        }

        map.set(word, map.get(word) + 1);
    }

    let f = new Map();
    let max = -Infinity;

    for (let word of map.keys()) {

        let frequency = map.get(word);
        max = Math.max(max, frequency);
        if (!f.has(frequency)) {

            f.set(frequency, []);
        }

        f.get(frequency).push(word)
    }

    let ans = [];

    for (let i = max; i > 0; --i) {
        let words = f.get(i);
        if (words) {
            words.sort();
            ans.push(...words);
        }
        if(ans.length>=k){
            ans=ans.slice(0,k+1);
            break;
        }
    }

    return ans;

};



//Encode/Decode Strings


// User function Template for javascript
/**
 * @param {string[]} strs
 * @returns {string}
 */

class Solution {
    // Function to encode a list of strings to a single string.
    encode(words) {

        let encodedStr = "";

        for (let word of words) {

            encodedStr += (word.length) + "#" + word;

        }
        return encodedStr;


    }

    // Function to decode a single string to a list of strings.
    decode(s) {
        //console.log(s)

        let i = 0;
        let ans=[];

        while (i<s.length) {

            let j = i;
            while (s[j] != "#") {

                j++;

            }
            let len=parseInt(s.substring(i,j));
            ans.push(s.substring(j+1,j+1+len));
            i=j+1+len;
        }

        return ans;

        // 2#ab3#abc


    }
}



//Climbing Stairs

/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {

    const dp = new Array(n + 1).fill(-1);

    let travel = (n) => {

        if (n == 0) {
            return 1;
        }
        if (n < 0) {
            return 0;
        }

        if (dp[n] != -1) {
            return dp[n];
        }
        return dp[n] = (travel(n - 1) + travel(n - 2));
    }

    return travel(n);

};


/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {

    const dp = new Array(n + 1).fill(-1);

    dp[0] = 1

    for (let i = 1; i <= n; i++) {

        dp[i] = dp[n - 1] + dp[n - 2] || 0;

    }

    return dp[n];

};



/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {

    let dp = new Array(nums.length + 1).fill(-1);


    let travel = (i) => {

        if (i < 0) {
            return 0;
        }
        if (dp[i] != -1) {
            return dp[i];
        }

        let s1 = nums[i] + travel(i - 2);
        let s2 = travel(i - 1);

        return dp[i] = Math.max(s1, s2);
    }
    return travel(nums.length - 1);
};



/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {

    let dp = new Array(nums.length + 1).fill(-1);


    let travel = (i) => {

        if (i < 0) {
            return 0;
        }
        if (dp[i] != -1) {
            return dp[i];
        }

        let s1 = nums[i] + travel(i - 2);
        let s2 = travel(i - 1);

        return dp[i] = Math.max(s1, s2);
    }
    return travel(nums.length - 1);
};



/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {

    let dp = new Array(nums.length + 1).fill(-1);

    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1] || 0);


    for (let i = 2; i < nums.length; i++) {

        let s1 = nums[i] + dp[i - 2];
        let s2 = dp[i - 1];

        dp[i] = Math.max(s1, s2);

    }
    return dp[nums.length - 1];
};




//House Robber II

/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {

    if (nums.length == 1) {
        return nums[0];
    }

    let dp = new Array(nums.length + 1).fill(-1);


    let travel = (i, nums) => {

        if (i >= nums.length) {
            return 0;
        }
        if (dp[i] != -1) {
            return dp[i];
        }

        let s1 = nums[i] + travel(i + 2, nums);
        let s2 = travel(i + 1, nums);

        return dp[i] = Math.max(s1, s2);
    }
    let ans1 = travel(0, nums.slice(0, nums.length - 1));
    dp = new Array(nums.length + 1).fill(-1);
    let ans2 = travel(0, nums.slice(1));
    return Math.max(ans1, ans2);
};



//Maximum Subarray

/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {

    let sum = 0;
    let max = -Infinity;

    for (let i = 0; i < nums.length; i++) {

        if (sum < 0) {
            sum = nums[i];
        }
        else {
            sum += nums[i];
        }
        max = Math.max(sum, max);
    }

    return max;
};


//Maximum Product Subarray

/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function (nums) {


    let max = -Infinity;
    let product = 1;

    for (let i = 0; i < nums.length; i++) {

        if (product == 0) {
            product = nums[i];
        }
        else {
            product *= nums[i];
        }

        max = Math.max(max, product);

    }

    product = 1;

    for (let i = nums.length - 1; i >= 0; i--) {

        if (product == 0) {
            product = nums[i];
        }
        else {
            product *= nums[i];
        }

        max = Math.max(max, product);

    }
    return max;
};


//Coin Change

/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function (coins, amount) {


    let travel = (i, amount) => {

        if (amount == 0) {
            return 0;
        }
        if (amount < 0 || i < 0) {
            return Infinity;
        }

        let count1 = 1 + travel(i, amount - coins[i])
        let count2 = travel(i - 1, amount);

        return Math.min(count1, count2);
    }

    let ans = travel(coins.length - 1, amount);


    return ans == Infinity ? -1 : ans;

};



// Coin Change II

/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var change = function (amount, coins) {


    let travel = (i, amount) => {

        if (amount == 0) {
            return 1;
        }
        if (amount < 0 || i < 0) {
            return 0;
        }

        let count1 = travel(i, amount - coins[i])
        let count2 = travel(i - 1, amount);

        return count1+count2;
    }

    let ans = travel(coins.length - 1, amount);


    return ans;

};


//Decode Ways

/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function (s) {


    const map = new Map();
    const dp = new Array(s.length).fill(-1);

    for (let i = 1; i <= 26; i++) {
        map.set(`${i}`, "");
    }

    let travel = (i) => {

        if (i < 0) {
            return 1;
        }

        if (dp[i] != -1) {
            return dp[i];
        }

        let count1 = 0;
        let count2 = 0;

        if (s[i] != "0") {
            count1 = travel(i - 1);
        }

        if ((i - 1) >= 0 && map.has(`${s[i - 1]}${s[i]}`)) {
            count2 = travel(i - 2);
        }
        return dp[i] = (count1 + count2);
    }
    return travel(s.length - 1);
};



//Word Break (DP view),

/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function (s, wordDict) {


    const map = new Map();
    const dp = new Array(s.length + 1).fill(null);

    for (let word of wordDict) {
        map.set(word, "");
    }


    const travel = (i) => {

        if (i == s.length) {
            return true;
        }

        if (dp[i] != null) {
            return dp[i];
        }

        for (let j = i; j < s.length; j++) {

            let word = s.substring(i, j + 1);

            if (map.has(word)) {
                let ans = travel(j + 1);
                if (ans) {
                    return ans;
                }
            }
        }
        return dp[i] = false;
    }

    return travel(0);

};


//Unique Paths

/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function (m, n) {



    let travel = (i, j) => {

        if (i >= m || j >= n) {
            return 0;
        }

        if (i == m - 1 && j == n - 1) {
            return 1;
        }

        return (travel(i + 1, j) + travel(i, j + 1));

    }

    return travel(0, 0);


};


//Longest Increasing Subsequence

/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function (nums) {

    const dp = new Array(nums.length).fill(new Array(nums.length));


    let travel = (i, j) => {

        if (i < 0) {
            return 0;
        }

        if (dp[i][j]) {
            return dp[i][j];
        }

        let count1 = 0;
        let count2 = 0;

        if (j == -1 || nums[i] < nums[j]) {
            count1 = 1 + travel(i - 1, i);
        }
        count2 = travel(i - 1, j);

        return dp[i][j] = Math.max(count1, count2);

    }

    return travel(nums.length - 1, -1);

};



//Russian Doll Envelopes (if in pool)


/**
 * @param {number[][]} envelopes
 * @return {number}
 */
var maxEnvelopes = function (envelopes) {


    envelopes.sort((a, b) => a[0] - b[0]);

    const dp = [];

    for (let i = 0; i < envelopes.length; i++) {
        dp.push(new Array(envelopes.length).fill(null));
    }

    let travel = (i, j) => {

        if (i >= envelopes.length) {
            return 0;
        }

        if (j !== -1 && dp[i][j] !== null) {
            return dp[i][j];
        }

        let count1 = 0;
        let count2 = 0;

        if (j == -1 || (envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1])) {
            count1 = 1 + travel(i + 1, i);
        }

        count2 = travel(i + 1, j);

        let ans = Math.max(count1, count2);
        if (j !== -1)
            dp[i][j] = ans;

        return ans;
    }
    return travel(0, -1);

};


//Partition Equal Subset Sum (if in pool)

/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function (nums) {

    let sum = nums.reduce((pv, cv) => (pv + cv));

    if (sum % 2 != 0) {
        return false;
    }

    sum = (sum / 2);

    let dp = [];

    for (let i = 0; i < nums.length; i++) {
        dp.push(new Array(sum + 1).fill(null));
    }


    let travel = (i, sum) => {

        if (sum == 0) {
            return true;
        }

        if (sum < 0 || i >= nums.length) {
            return false;
        }

        if (dp[i][sum] !== null) {
            return dp[i][sum];
        }

        let res1 = travel(i + 1, sum - nums[i]);
        if (res1) {
            return res1;
        }
        let res2 = travel(i + 1, sum);
        return dp[i][sum] = res2;

    }

    return travel(0, sum);


};


//Path Sum

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function (root, targetSum) {

    let travel = (root, sum) => {

        if (!root) {
            return false;
        }

        if (!root.left && !root.right && root.val === sum) {
            return true;
        }

        let res = travel(root.left, sum - root.val);
        if (res) {
            return res;
        }
        res = travel(root.right, sum - root.val);
        return res;

    }
    return travel(root, targetSum);

};


Kth Smallest in BST

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function (root, k) {

    let count = 0;
    let ans = -1;

    let travel = (root) => {

        if (!root) {
            return;
        }

        travel(root.left);

        ++count;

        if (count == k) {
            ans = root.val;
        }
        if (count >= k) {
            return;
        }


        travel(root.right);
    }

    travel(root);

    return ans;
};



//Validate BST

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function (root) {

    let travel = (root, lmax, rmax) => {


        if (!root) {
            return true;
        }

        if (root.val <= lmax || root.val >= rmax) {
            return false;
        }

        let res = travel(root.left, lmax, root.val);
        if (!res) {
            return res;
        }
        res = travel(root.right, root.val, rmax);

        return res;

    }

    return travel(root, -Infinity, Infinity);

};



//LCA

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function (root, p, q) {

    let travel = (root) => {

        if (!root || root == p || root == q) {
            return root
        }

        let left = travel(root.left);
        let right = travel(root.right);
        if (left && right) {
            return root;
        }

        return left || right;
    }

    return travel(root);

};



//Build Tree from Preorder+Inorder

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function (preorder, inorder) {

    let map = new Map();
    let preIndex = 0;

    for (let i = 0; i < inorder.length; i++) {
        map.set(inorder[i], i);
    }

    let travel = (left, right) => {

        if (left > right) {
            return null;
        }

        let node = new TreeNode(preorder[preIndex]);
        let mid = map.get(preorder[preIndex]);
        ++preIndex;

        node.left = travel(left, mid - 1)
        node.right = travel(mid + 1, right);

        return node;
    }



//Build Tree from Preorder+Postorder


/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var constructFromPrePost = function (pre, post) {
  let i = 0, j = 0;

  function build() {
    const root = new TreeNode(pre[i++]);

    if (root.val !== post[j]) {
      root.left = build();
    }
    if (root.val !== post[j]) {
      root.right = build();
    }

    j++;
    return root;
  }

  return build();
};







//Build Tree from Inorder+Postorder

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function (inorder, postorder) {

    let map = new Map();

    for (let i = 0; i < inorder.length; i++) {
        map.set(inorder[i], i);
    }

    let postorderIndex = postorder.length - 1;

    let travel = (left, right) => {

        if (left > right) {
            return null;
        }

        let node = new TreeNode(postorder[postorderIndex]);
        let mid = map.get(postorder[postorderIndex]);
        --postorderIndex;

        node.right = travel(mid + 1, right);
        node.left = travel(left, mid - 1);

        return node;
    }

    return travel(0, postorder.length - 1)
};



//Serialize/Deserialize

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function (root) {

    let preorder = [];
    let inorder = [];
    let i = 0;
    let map = new Map();

    let travel = (root) => {

        if (!root) {
            return root;
        }

        if (!map.has(root)) {
            map.set(root, i++);
        }

        preorder.push(`${map.get(root)}_${root.val}`);
        travel(root.left);
        inorder.push(`${map.get(root)}_${root.val}`);
        travel(root.right);
    }

    travel(root);

    let str = preorder.join(",");
    str = str + "#" + inorder.join(",");

    return str;

};


/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function (data) {

    if (data == '#') {
        return null;
    }
    data = data.split("#");
    console.log(data);

    let preorder = data[0].split(",")
    let inorder = data[1].split(",");


    let map = new Map();
    for (let i = 0; i < inorder.length; i++) {
        map.set(inorder[i], i);
    }
    let preIndex = 0;

    let travel = (left, right) => {

        if (left > right) {
            return null;
        }

        let val = Number(preorder[preIndex].split('_')[1]);

        let node = new TreeNode(val);
        let mid = map.get(preorder[preIndex]);
        ++preIndex;
        node.left = travel(left, mid - 1);
        node.right = travel(mid + 1, right);


        return node;
    }

    return travel(0, preorder.length - 1);

};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */




//Word Ladder

/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {number}
 */
var ladderLength = function (beginWord, endWord, wordList) {

    let ans = Infinity;

    let map = new Map();
    for (let word of wordList) {
        map.set(word, "");
    }

    if (!map.has(endWord)) {
        return 0;
    }

    map.delete(beginWord);

    let travel = (count, word) => {

        //console.log(count, word)

        if (count > ans) {
            return;
        }
        if (word.join('') == endWord) {
            ans = Math.min(ans, count);
            return;
        }

        for (let j = 0; j < word.length; j++) {

            for (let i = 0; i < 26; i++) {

                let char = String.fromCharCode('a'.charCodeAt(0) + i);
                let c = word[j];
                word[j] = char;
                let nw = word.join('');
                if (map.has(nw)) {
                    map.delete(nw);
                    travel(count + 1, word);
                    map.set(nw, "");
                }
                word[j] = c;

            }
        }
    }

    travel(0, beginWord.split(''), 0);

    return ans == Infinity ? 0 : ans + 1;
};


/**
 * @param {number} n
 * @return {number}
 */
var hammingWeight = function (n) {

    let count = 0;

    while (n > 0) {

        n &= (n - 1);
        ++count;

    }
    return count;
};

// What happens when you subtract 1?

// When you do n - 1:

// The rightmost 1 becomes 0

// All bits after that become 1



/**
 * @param {number} n
 * @return {number[]}
 */
var countBits = function (n) {


    let ans = new Array(n + 1).fill(0);
    for (let i = 1; i <= n; i++) {
        ans[i] = ans[(i - 1) & i] + 1;
    }
    return ans;

};



/**
 * @param {number} n
 * @return {number}
 */
var reverseBits = function (n) {

    let ans = 0;

    for (let i = 1; i <= 32; i++) {
        ans = (ans << 1) | (n & 1);
        n = n >> 1;
    }
    return ans;

};


/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {

    let dp = [];

    for (let i = 0; i < prices.length; i++) {
        dp.push(new Array(2).fill(-1));
    }

    let travel = (i, buy) => {

        if (i >= prices.length) {
            return 0;
        }

        if (dp[i][buy] != -1) {
            return dp[i][buy];
        }

        if (buy == 1) {

            let p1 = -prices[i] + travel(i + 1, 0);
            let p2 = travel(i + 1, 1);

            return dp[i][buy] = Math.max(p1, p2);
        }
        else {

            let p1 = prices[i] + travel(i + 2, 1);
            let p2 = travel(i + 1, 0);

            return dp[i][buy] = Math.max(p1, p2);

        }
    }

    return travel(0, 1);

};



/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function (p, q) {


    let dfs = (p, q) => {

        if (p == null && q == null) {
            return true;
        }
        if (p == null || q == null || p.val != q.val) {
            return false;
        }

        return dfs(p.left, q.left) && dfs(p.right, q.right);

    }

    return dfs(p, q);
};



/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} subRoot
 * @return {boolean}
 */
var isSubtree = function (root, subRoot) {

    let isSameTree = (p, q) => {

        if (!p && !q) {
            return true;
        }
        if (!p || !q || p.val != q.val) {
            return false;
        }

        return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
    }

    let dfs = (p, q) => {

        if (!p) {
            return false;
        }

        if (isSameTree(p, q)) {
            return true;
        }

        return dfs(p.left, q) || dfs(p.right, q)
    }

    return dfs(root, subRoot);
};


/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxPathSum = function (root) {

    let ans = -Infinity;

    let travel = (root) => {

        if (!root) {
            return 0;
        }

        let left = Math.max(0, travel(root.left));
        let right = Math.max(0, travel(root.right));

        ans = Math.max(ans, root.val + left + right);

        return root.val + Math.max(left, right);
    }

    return travel(root);
};



//Cheapest Flights Within K Stops

/*
 * @lc app=leetcode id=787 lang=javascript
 *
 * [787] Cheapest Flights Within K Stops
 */

// @lc code=start
/**
 * @param {number} n
 * @param {number[][]} flights
 * @param {number} src
 * @param {number} dst
 * @param {number} k
 * @return {number}
 */
var findCheapestPrice = function (n, flights, src, dst, k) {

    let dis = new Array(n).fill(Infinity);

    dis[src] = 0;

    for (let i = 1; i <= (k + 1); i++) {

        let t = [...dis];


        for (let [u, v, w] of flights) {

            if (dis[u] != Infinity) {
                t[v] = Math.min(t[v], dis[u] + w);
            }
        }
        dis = t;
    }

    return dis[dst] == Infinity ? -1 : dis[dst];

};


//Swim in Rising Water

/**
 * @param {number[][]} grid
 * @return {number}
 */
var swimInWater = function (grid) {


    let min = Infinity;
    let n = grid.length;

    let vis = new Array(n).fill(0).map(() => new Array(n).fill(false));
    let dp = new Array(n).fill(0).map(() => new Array(n).fill(Infinity));
    let dirs = [
        [1, 0],
        [0, 1],
        [-1, 0],
        [0, -1]
    ];

    let travel = (i, j, t) => {

        if (t >= min) {
            return;
        }

        if (i == n - 1 && j == n - 1) {
            min = Math.min(min, t);
            return
        }

        if (t >= dp[i][j]) {
            return;
        }

        dp[i][j] = t;

        vis[i][j] = true

        for (let [dx, dy] of dirs) {

            let x = i + dx;
            let y = j + dy;

            if (x < 0 || y < 0 || x >= n || y >= n || vis[x][y]) {
                continue;
            }

            travel(x, y, Math.max(t, grid[x][y]))
        }
        vis[i][j] = false
    }

    travel(0, 0, grid[0][0]);
    return min;

};


//Min Cost to Connect All Points: krushkal

/**
 * @param {number[][]} points
 * @return {number}
 */
var minCostConnectPoints = function (points) {


    let edges = [];

    for (let i = 0; i < points.length; i++) {

        let [x1, y1] = points[i];

        for (let j = i + 1; j < points.length; j++) {

            let [x2, y2] = points[j];
            let dis = Math.abs(x1 - x2) + Math.abs(y1 - y2);

            edges.push([i, j, dis]);

        }
    }


    let parent = new Array(points.length).fill(0).map((v, i) => i);
    let size = new Array(points.length).fill(0);

    let findP = (i) => {

        if (parent[i] != i) {
            parent[i] = findP(parent[i]);
        }
        return parent[i];
    }


    let merge = (u, v) => {


        let pu = findP(u);
        let pv = findP(v);


        if (pu == pv) {
            return false;
        }

        if (size[pu] >= size[pv]) {
            parent[pv] = pu;
            ++size[pu];
        }
        else {
            parent[pu] = pv;
            ++size[pv];
        }
        return true;
    }

    edges.sort((a, b) => a[2] - b[2]);

    let cost = 0;

    for (let [u, v, w] of edges) {

        if (merge(u, v)) {

            cost += w;
        }
    }
    return cost;
};


//Min Cost to Connect All Points: Prims

/**
 * @param {number[][]} points
 * @return {number}
 */
var minCostConnectPoints = function (points) {

    let g = new Map();

    for (let i = 0; i < points.length; i++) {

        let [x1, y1] = points[i];


        for (let j = i + 1; j < points.length; j++) {

            let [x2, y2] = points[j];
            let dis = Math.abs(x1 - x2) + Math.abs(y1 - y2);

            if (!g.has(i)) {
                g.set(i, []);
            }
            if (!g.has(j)) {
                g.set(j, []);
            }

            g.get(i).push([j, dis]);
            g.get(j).push([i, dis])

        }
    }

    let dis = new Array(points.length).fill(Infinity);
    let vis = new Array(points.length).fill(false)

    let totalCost = 0;
    let queue = [[0, 0]];
    dis[0] = 0;

    while (queue.length > 0) {

        queue.sort((a, b) => a[1] - b[1]);
        let [u, cost] = queue.shift();

        if (vis[u]) {
            continue;
        }
        vis[u] = true;
        totalCost += cost;

        for (let [v, w] of g.get(u) || []) {

            if (!vis[v] && dis[v] > w) {
                dis[v] = w;
                queue.push([v, w]);
            }
        }
    }


    return totalCost;
};


//First Missing Positive

/**
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function (nums) {

    for (let i = 0; i < nums.length; i++) {

        while (nums[i] > 0 && nums[i] <= nums.length && nums[i] - 1 != i) {

            let index = nums[i] - 1;

            if (nums[i] == nums[index]) {
                break;
            }
            [nums[i], nums[index]] = [nums[index], nums[i]];
        }
    }

    for (let i = 0; i < nums.length; i++) {
        if ((i + 1) != nums[i]) {
            return i + 1;
        }
    }
    return nums.length + 1;
};



//LRU Cache using DLL

class Node {

    constructor(key, val) {

        this.val = val;
        this.key = key;
        this.prev = null;
        this.next = null;
    }
}


/**
 * @param {number} capacity
 */
var LRUCache = function (capacity) {

    this.capacity = capacity;
    this.cache = new Map();
    this.head = new Node(0, 0);
    this.tail = new Node(0, 0);
    this.head.next = this.tail;
    this.tail.prev = this.head;
};

LRUCache.prototype.add = function (node) {

    node.next = this.head.next;
    node.prev = this.head;
    this.head.next.prev = node;
    this.head.next = node;

    return node;
}

LRUCache.prototype.remove = function (node) {

    node.prev.next = node.next;
    node.next.prev = node.prev;
}



/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function (key) {


    if (this.cache.has(key)) {

        let node = this.cache.get(key);
        this.remove(node);
        this.add(node);
        return node.val;

    }

    return -1;
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function (key, value) {


    if (this.cache.has(key)) {

        let node = this.cache.get(key);
        node.val = value;
        this.remove(node);
        this.add(node);
        return;
    }

    if (this.capacity == this.cache.size) {

        let lru = this.tail.prev;
        this.remove(lru);
        this.cache.delete(lru.key);

    }

    let node = new Node(key, value);
    this.add(node);
    this.cache.set(key, node);

};

/** 
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */


//LRU Cache using Set

/**
 * @param {number} capacity
 */
var LRUCache = function (capacity) {
    this.capacity = capacity;
    this.set = new Set();
    this.cache = new Map();
};

LRUCache.prototype.add = function (key) {
    this.set.add(key);
}

LRUCache.prototype.remove = function (key) {
    this.set.delete(key);
}

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function (key) {

    if (this.cache.has(key)) {

        this.remove(key);
        this.add(key);
        return this.cache.get(key);
    }
    return -1;
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function (key, value) {

    if (this.cache.has(key)) {
        this.remove(key);
        this.add(key);
        this.cache.set(key, value);
        return;
    }

    if (this.capacity == this.cache.size) {

        let lru = this.set.values().next().value;
        this.remove(lru);
        this.cache.delete(lru);
    }

    this.add(key);
    this.cache.set(key, value);
};



//Min Stack (O(1) space)


var MinStack = function () {

    this.stack = [];
    this.minStack = [];
    return;
};

/** 
 * @param {number} val
 * @return {void}
 */
MinStack.prototype.push = function (val) {

    this.stack.push(val);
    if (!this.minStack.length) {
        this.minStack.push(val);
        return;
    }
    this.minStack.push(Math.min(val, this.minStack[this.minStack.length - 1]));

};

/**
 * @return {void}
 */
MinStack.prototype.pop = function () {

    this.stack.pop();
    this.minStack.pop();

};

/**
 * @return {number}
 */
MinStack.prototype.top = function () {

    return this.stack[this.stack.length - 1];

};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function () {

    return this.minStack[this.minStack.length - 1];

};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(val)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */





//Insert Delete GetRandom O(1)


var RandomizedSet = function () {

    this.arr = [];
    this.map = new Map();

};

/** 
 * @param {number} val
 * @return {boolean}
 */
RandomizedSet.prototype.insert = function (val) {

    if (this.map.has(val)) {
        return false;
    }

    this.arr.push(val);
    this.map.set(val, this.arr.length - 1);
    return true;
};

/** 
 * @param {number} val
 * @return {boolean}
 */
RandomizedSet.prototype.remove = function (val) {

    if (!this.map.has(val)) {
        return false;
    }

    let index = this.map.get(val);
    this.arr[index] = this.arr[this.arr.length - 1];
    this.arr.pop();
    this.map.delete(val);
    this.map.set(this.arr[index], index);
    return true;

};

/**
 * @return {number}
 */
RandomizedSet.prototype.getRandom = function () {

    let index = Math.floor(Math.random() * this.arr.length);
    return this.arr[index];

};

/** 
 * Your RandomizedSet object will be instantiated and called as such:
 * var obj = new RandomizedSet()
 * var param_1 = obj.insert(val)
 * var param_2 = obj.remove(val)
 * var param_3 = obj.getRandom()
 */


// Design HashMap

var MyHashMap = function () {

    this.size = 1000;
    this.map = new Array(1000).fill(0).map(() => []);

};

MyHashMap.prototype.hash = function (key) {
    return key % this.size;
};

MyHashMap.prototype.put = function (key, value) {

    let index = this.hash(key);
    let arr = this.map[index];

    for (let e of arr) {

        if (e[0] == key) {
            e[1] = value;
            return;
        }
    }
    arr.push([key, value]);

};

MyHashMap.prototype.get = function (key) {


    let index = this.hash(key);
    let arr = this.map[index];

    for (let e of arr) {

        if (e[0] == key) {
            return e[1];
        }
    }
    return -1;

};

MyHashMap.prototype.remove = function (key) {

    let index = this.hash(key);
    let arr = this.map[index];

    for (let i = 0; i < arr.length; i++) {

        if (arr[i][0] == key) {
            arr.splice(i, 1);
            return;
        }
    }

};



//Sqrt(x)

class Solution {
    squareRoot(n, p) {

        let ans = 0;
        let left = 1;
        let right = n;

        while (left <= right) {

            let mid = Math.floor((left + right) / 2);

            if (mid * mid == n) {
                return mid;
            }
            else if (mid * mid > n) {
                right = mid - 1;
            }
            else {
                ans = left;
                left = mid + 1;
            }
        }
        p = 1 / Math.pow(10, p);

        while (((ans + p) * (ans + p)) <= n) {
            ans = (ans + p)
        }
        return ans;
    }

    sqrtHighPrecision(x) {
        let left = 0, right = x;
        const eps = 1e-6;

        while (right - left > eps) {
            let mid = (left + right) / 2;

            if (mid * mid <= x) {
                left = mid;
            } else {
                right = mid;
            }
        }

        return left;
    }
} 


//Happy Number,

/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function (n) {

    let set = new Set();
    let sum = 0;

    while (n != 1 && !set.has(n)) {

        set.add(n);

        while (n > 0) {

            let num = n % 10;
            sum += (num * num);
            n /= 10;
        }
        n = sum;
    }

    return n == 1;
};


//Ugly Number II

/**
 * @param {number} n
 * @return {number}
 */
var nthUglyNumber = function (n) {


    let dp = new Array(n).fill(Infinity);
    dp[0] = 1;
    let i2 = 0;
    let i3 = 0;
    let i5 = 0;

    for (let i = 1; i <= n; i++) {

        let num1 = dp[i2] * 2;
        let num2 = dp[i3] * 3;
        let num3 = dp[i5] * 5;

        dp[i] = Math.min(num1, num2, num3);

        if (dp[i] == num1) {
            ++i2;
        }
        if (dp[i] == num2) {
            ++i3;
        }
        if (dp[i] == num3) {
            ++i5;
        }
    }
    //console.log(dp)

    return dp[n - 1];

};


/**
 * @param {number} n
 * @return {number}
 */
// var nthUglyNumber = function (n) {

//     let heap = [1];
//     let cache = new Set();
//     cache.add(1);

//     for (let i = 1; i <= n; i++) {
//         let num = heap.shift();

//         for (let pf of [2, 3, 5]) {

//             let newNum = num * pf;

//             if (!cache.has(newNum)) {
//                 cache.add(newNum);
//                 heap.push(newNum);
//             }
//         }
//         heap.sort((a, b) => a - b);

//         if (i == n) {
//             return num;
//         }
//     }
// };


Merge sort:

/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function (nums) {

    let merge = (left, mid, right) => {

        let t = [];
        let i = left;
        let j = mid + 1;

        while (i <= mid && j <= right) {

            if (nums[j] >= nums[i]) {

                t.push(nums[i]);
                ++i;
            }
            else {
                t.push(nums[j]);
                ++j;
            }
        }

        while (i <= mid) {
            t.push(nums[i]);
            ++i;
        }

        while (j <= right) {
            t.push(nums[j]);
            ++j;
        }
        i = left;
        for (let k = 0; k < t.length; k++) {
            nums[i] = t[k];
            ++i;
        }


    }

    let mergeSort = (left, right) => {

        if (left >= right) {
            return;
        }
        let mid = left + Math.floor((right - left) / 2);
        mergeSort(left, mid);
        mergeSort(mid + 1, right);
        merge(left, mid, right);
    }
    mergeSort(0, nums.length - 1);

    return nums;
};


//Count Primes,

/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function (n) {
    if (n <= 2) return 0;

    const isPrime = new Array(n).fill(true);
    isPrime[0] = false;
    isPrime[1] = false;

    for (let p = 2; p < n; p++) {
        if (isPrime[p]) {
            for (let i = 2 * p; i < n; i += p) {
                isPrime[i] = false;
            }
        }
    }

    let count = 0;
    for (let i = 2; i < n; i++) {
        if (isPrime[i]) count++;
    }

    return count;
};


function isPrime(n) {
    if (n <= 1) return false;
    if (n === 2) return true;
    if (n % 2 === 0) return false;

    const limit = Math.sqrt(n);

    for (let i = 3; i <= limit; i += 2) {
        if (n % i === 0) return false;
    }

    return true;
}


//Multiply Strings

/**
 * @param {string} num1
 * @param {string} num2
 * @return {string}
 */
var multiply = function (num1, num2) {


    let m = num1.length;
    let n = num2.length;
    let ans = new Array(m + n).fill(0);

    for (let i = n - 1; i >= 0; i--) {
        for (let j = m - 1; j >= 0; j--) {

            let mul = (num2[i] - '0') * (num1[j] - '0');
            let sum = ans[i + j + 1] + mul;
            ans[i + j + 1] = (sum % 10);
            ans[i + j] += (Math.floor(sum / 10));
        }
    }
    //console.log(ans);

    while (ans[0] == 0) {
        ans.shift();
    }
    ans = ans.join("");
    return ans == '' ? '0' : ans;
};


//Integer to Roman
/**
 * @param {number} num
 * @return {string}
 */
var intToRoman = function (num) {

    const values = [
        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1
    ];
    const symbols = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'];

    let ans = '';

    for (let i = 0; i < values.length; i++) {

        while (num >= values[i]) {
            ans += symbols[i];
            num -= values[i];
        }
    }
    return ans;
};

//Roman to Integer
/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function (s) {

    const map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 };
    let ans = 0;

    for (let i = 0; i < s.length; i++) {

        ans += map[s[i]];

        if ((i - 1) >= 0 && map[s[i]] > map[s[i - 1]]) {
            ans -= (2 * map[s[i - 1]]);
        }
    }
    return ans
};


//Meeting room

class Solution {
    canAttend(arr) {
        arr.sort((a, b) => a[0] - b[0]);

        let endTime = arr[0][1];

        for (let i = 1; i < arr.length; i++) {

            if (endTime > arr[i][0]) {
                return false;
            }
            endTime = arr[i][1];
        }
        return true;

    }
}


//Meeting Rooms II

class Solution {
    minMeetingRooms(start, end) {

        start.sort((a, b) => a - b);
        end.sort((a, b) => a - b);
        let ans = 0;
        let j = 0;
        let count = 0;

        for (let i = 0; i < start.length;) {

            if (end[j] > start[i]) {
                ++count;
                ans = Math.max(ans, count);
                ++i;
            }
            else {
                ++j;
                --count;
            }
        }
        return ans;

    }
}


//Insert Interval

/**
 * @param {number[][]} intervals
 * @param {number[]} newInterval
 * @return {number[][]}
 */
var insert = function (intervals, newInterval) {

    let ans = [];
    let isInserted = false;

    for (let i = 0; i < intervals.length;) {

        if (newInterval[0] < intervals[i][0] && !isInserted) {
            ans.push(newInterval);
            isInserted = true;
        }
        else {
            ans.push(intervals[i]);
            i++;
        }
    }
    if (!isInserted) {
        ans.push(newInterval);
    }
    intervals = ans;
    ans = [];
    ans.push(intervals[0]);

    for (let i = 1; i < intervals.length; i++) {

        if (ans[ans.length - 1][1] >= intervals[i][0]) {
            ans[ans.length - 1][1] = Math.max(ans[ans.length - 1][1], intervals[i][1]);
        }
        else {
            ans.push(intervals[i]);
        }
    }
    return ans;
};

//Minimum Number of Arrows to Burst Balloons

/**
 * @param {number[][]} points
 * @return {number}
 */
var findMinArrowShots = function (intervals) {

    intervals.sort((a, b) => a[0] - b[0]);

    let start = intervals[0][0];
    let end = intervals[0][1];
    let count = 1;

    for (let i = 1; i < intervals.length; i++) {

        if (end >= intervals[i][0]) {
            start = intervals[i][0]
            end = Math.min(end, intervals[i][1]);

        }
        else {
            start = intervals[i][0];
            end = intervals[i][1];
            ++count;
        }
    }
    return count;
};


//Reorganize String

/**
 * @param {string} s
 * @return {string}
 */
var reorganizeString = function (s) {

    const map = new Map();
    const maxAllowdFreq = Math.ceil(s.length / 2);

    for (let i = 0; i < s.length; i++) {

        if (!map.has(s[i])) {
            map.set(s[i], 0);
        }
        let freq = map.get(s[i]) + 1;
        if (freq > maxAllowdFreq) {
            return "";
        }
        map.set(s[i], freq);
    }

    const heap = [...map.entries()];
    let ans = '';
    while (heap.length > 1) {

        heap.sort((a, b) => b[1] - a[1]);
        let char1 = heap.shift();
        let char2 = heap.shift();
        ans += char1[0];
        ans += char2[0];

        char1[1] -= 1;
        char2[1] -= 1;
        if (char1[1] > 0) {
            heap.push(char1);
        }
        if (char2[1] > 0) {
            heap.push(char2);
        }
    }
    if (heap.length == 1) {
        ans += heap[0][0];

    }
    return ans;

};


/**
 * @param {number[][]} points
 * @param {number} k
 * @return {number[][]}
 */
var kClosest = function (points, k) {

    const heap = [];
    const ans = [];

    for (let [x, y] of points) {
        heap.push([x, y, x * x + y * y]);
    }

    heap.sort((a, b) => a[2] - b[2]);
    //console.log(heap)

    while (k > 0) {
        let [x, y, dis] = heap.shift();
        ans.push([x, y]);
        --k;
    }
    return ans;

};


/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function (nums, k) {

    const freq = new Map();
    for (let num of nums) {

        if (!freq.has(num)) {
            freq.set(num, 0);
        }
        freq.set(num, freq.get(num) + 1);
    }

    const buckets = new Array(nums.length + 1).fill(0).map(() => []);

    for (let [val, f] of freq.entries()) {
        buckets[f].push(val);
    }

    let ans = [];

    for (let i = nums.length; i >= 0; --i) {

        let bucket = buckets[i];
        for (let j = 0; j < bucket.length; j++) {

            ans.push(bucket[j]);
            if (ans.length >= k) {
                return ans;
            }
        }
    }
    return ans;
};

//Letter Combinations of a Phone Number

/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function (digits) {

    if (digits.length == 0)
        return [];

    const digitToLetters = {
        2: ['a', 'b', 'c'],
        3: ['d', 'e', 'f'],
        4: ['g', 'h', 'i'],
        5: ['j', 'k', 'l'],
        6: ['m', 'n', 'o'],
        7: ['p', 'q', 'r', 's'],
        8: ['t', 'u', 'v'],
        9: ['w', 'x', 'y', 'z']
    };

    const ans = [];

    const travel = (i, t) => {

        if (t.length == digits.length) {
            ans.push(t);
            return;
        }
        let chars = digitToLetters(digits[i]);
        for (const c of chars) {
            travel(i + 1, t + c);
        }
        return ans;
    }

    return travel(0, "");
};



//N-Queens

/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function (n) {

    const ans = [];
    const board = [];

    const cols = new Set();
    const left = new Set();
    const right = new Set();

    for (let i = 0; i < n; i++) {
        board.push(new Array(n).fill("."));
    }


    let travel = (row) => {

        if (row == n) {

            ans.push(board.map((v, i) => v.join('')));
            return;
        }
        for (let col = 0; col < n; col++) {

            if (cols.has(col) || left.has(row - col) || right.has(row + col)) {
                continue;
            }

            cols.add(col);
            left.add(row - col);
            right.add(row + col);
            board[row][col] = 'Q';
            travel(row + 1);
            cols.delete(col);
            left.delete(row - col);
            right.delete(row + col);
            board[row][col] = '.';
        }
        return ans;
    }

    return travel(0);

};
