Study plan + must‚Äëknow templates (4 weeks, 6 days/week)
Week 1: Arrays, Hashing, Two Pointers, Sliding Window, Stack
Day 1 (Arrays/Hashing): Product of Array Except Self, Longest Consecutive Sequence, Majority Element, Missing Number.
Day 2 (Intervals + Prefix): Merge Intervals, Non-overlapping Intervals, Merge Sorted Array, Set Matrix Zeroes, Subarray Sum Equals K.
Day 3 (Two Pointers): 3Sum, Container With Most Water, Trapping Rain Water, Backspace String Compare, Remove K Digits.
Day 4 (Sliding Window I): Longest Substring Without Repeating Characters, Permutation in String, Find All Anagrams in a String, Sliding Window Maximum.
Day 5 (Sliding Window II): Longest Repeating Character Replacement, Minimum Window Substring, Decode Ways, Sort Colors.
Day 6 (Review/Mocks): Re‚Äëdo misses; 1 mock timed set (4 problems mixed).
Week 2: Linked Lists, Binary Search, Trees (basics), Heaps/Greedy
Day 1 (Linked List I): Reverse Linked List, Merge Two Sorted Lists, Remove Nth Node From End, Reorder List.
Day 2 (Linked List II): Add Two Numbers, Linked List Cycle, Linked List Cycle II, Palindrome Linked List, Intersection of Two Linked Lists, Copy List with Random Pointer.
Day 3 (Binary Search): Binary Search, First Bad Version, Find Peak Element, Search a 2D Matrix, Search in Rotated Sorted Array, Find Minimum in Rotated Sorted Array, Median of Two Sorted Arrays, Koko Eating Bananas.
Day 4 (Trees I): Invert Binary Tree, Maximum Depth, Balanced Binary Tree, Diameter of Binary Tree, Binary Tree Level Order Traversal, Right Side View.
Day 5 (Heaps/Greedy/Intervals): Kth Largest Element, Task Scheduler, Car Fleet, Largest Rectangle in Histogram, Merge K Sorted Lists, Find Median from Data Stream.
Day 6 (Review/Mocks): Mixed set; revisit weak topics.
Week 3: Graphs, Union-Find, Backtracking, Tries, Matrix BFS
Day 1 (Graphs BFS/DFS): Number of Islands, Clone Graph, Rotting Oranges, Pacific Atlantic Water Flow.
Day 2 (Topo/Ordering): Course Schedule, course-schedule-ii, Alien Dictionary, Graph Valid Tree, Redundant Connection, Network Delay Time, Accounts Merge.
Day 3 (Union-Find): Graph Valid Tree, Redundant Connection, Accounts Merge, Number of Islands (UF variant).
Day 4 (Backtracking): Generate Parentheses, Permutations, Subsets, Combination Sum, Word Search (if in your pool), Word Break.
Day 5 (Trie/Strings): Implement Trie, Add and Search Word, Top K Frequent Words, Encode/Decode Strings.
Day 6 (Review/Mocks): 1 full mock; re‚Äëdo 3 hardest.
Week 4: Dynamic Programming, Advanced Trees, Mixed Review
Day 1 (1D DP): Climbing Stairs, House Robber, House Robber II, Maximum Subarray, Maximum Product Subarray.
Day 2 (Knapsack/Coins): Coin Change, Coin Change II (if in pool), Decode Ways (DP view), Word Break (DP view), Unique Paths.
Day 3 (LIS/Greedy DP): Longest Increasing Subsequence, Russian Doll Envelopes (if in pool), Partition Equal Subset Sum (if in pool).
Day 4 (Tree/Graph DP & Construction): Path Sum, Kth Smallest in BST, Validate BST, LCA, Build Tree from Preorder+Inorder, Serialize/Deserialize.
Day 5 (Mixed hard review): Minimum Window Substring, Sliding Window Maximum, Median of Two Sorted Arrays, Task Scheduler, Word Ladder.
Day 6 (Final mock + reflections): 1‚Äì2 timed mocks; compile a mistakes log.




/**

Anagram: s2 is angram of s1 if s1 chas jumbled. no addtion, subtraction of chars and lenght of s1 == s2.



**/




/**
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function (strs) {


    let map = new Map();

    for (let str of strs) {
        let counts = new Array(26).fill(0);

        for (let char of str) {

            let alpha = char.charCodeAt(0) - 97;
            ++counts[alpha];
        }

        counts = counts.join(',');

        if (!map.has(counts)) {
            map.set(counts, []);
        }
        map.get(counts).push(str);
    }

    return Array.from(map.values());
};

//111000// ElevenOn1
//111000// OneEleven




/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function (nums, k) {

    let frequency = new Map();
    for (let num of nums) {

        if (!frequency.has(num)) {
            frequency.set(num, 0);
        }
        frequency.set(num, frequency.get(num) + 1);
    }



    let buckets = new Array(nums.length + 1).fill(null).map(() => []);

    for (let [key, value] of frequency.entries()) {
        buckets[value].push(key);
    }

    let ans = [];

    for (let i = buckets.length - 1; i >= 0 && ans.length < k; --i) {

        for (let num of buckets[i]) {

            if (ans.length >= k) {
                break;
            }
            ans.push(num);
        }
    }
    return ans;

};


/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function (nums) {

    let ans = new Array(nums.length).fill(0);

    let prefix = 1;

    for (let i = 0; i < nums.length; i++) {

        ans[i] = prefix;
        prefix *= nums[i];

    }

    let suffix = 1;

    for (let i = nums.length - 1; i >= 0; i--) {

        ans[i] *= suffix;
        suffix *= nums[i];

    }

    return ans;

};


Longest Consecutive Sequence:

/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function (nums) {

    if (nums.length == 0) {
        return 0;
    }


    let uniqueNums = new Set(nums);
    let max = -Infinity;

    for (let num of uniqueNums) {

        if (uniqueNums.has(num - 1)) {
            continue;
        }

        let count = 0;

        while (uniqueNums.has(num)) {

            ++count;
            ++num;
        }
        max = Math.max(max, count);
    }
    return max;
};


Majority Element:

/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function (nums) {

    let count = 0;
    let c = '';

    for (let num of nums) {

        if (count == 0 || c == num) {
            c = num;
            ++count
        } else {
            --count;
        }
    }
    return c;
};


Majority Element 2:

/**
 * @param {number[]} nums
 * @return {number[]}
 */

var majorityElement = function (nums) {


    let e1 = null;
    let e2 = null;
    let count1 = 0;
    let count2 = 0;

    for (let n of nums) {


        if (e1 === n) {
            ++count1;
        }

        else if (e2 === n) {
            ++count2;
        }

        else if (count1 == 0) {
            e1 = n;
            count1 = 1;
        }
        else if (count2 == 0) {
            e2 = n;
            count2 = 1;
        }
        else {

            --count1;
            --count2;

        }
    }

    console.log(e1, e2);

    count1 = 0;
    count2 = 0;
    for (let num of nums) {
        if (num === e1) count1++;
        else if (num === e2) count2++;
    }




    let c = Math.floor(nums.length / 3);
    let ans = [];

    if (count1 > c) {
        ans.push(e1);
    }

    if (count2 > c) {
        ans.push(e2);
    }

    return ans;

};



Missing Number:


/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    let n = nums.length;
    let expectedSum = (n * (n + 1)) / 2;
    let actualSum = nums.reduce((a, b) => a + b, 0);
    return expectedSum - actualSum;
};


var missingNumber = function(nums) {
    let n = nums.length;
    let xor = 0;

    for (let i = 0; i <= n; i++) {
        xor ^= i;
    }
    for (let num of nums) {
        xor ^= num;
    }
    return xor;
};




Merge Intervals:


/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    if (intervals.length <= 1) return intervals;

    // Step 1: Sort by start time
    intervals.sort((a, b) => a[0] - b[0]);

    let merged = [intervals[0]];

    // Step 2: Merge overlaps
    for (let i = 1; i < intervals.length; i++) {
        let last = merged[merged.length - 1];
        let current = intervals[i];

        if (current[0] <= last[1]) {
            // Overlap ‚Üí merge
            last[1] = Math.max(last[1], current[1]);
        } else {
            // No overlap ‚Üí push new interval
            merged.push(current);
        }
    }

    return merged;
};


/**
 * @param {number[][]} intervals
 * @return {number}
 */
var eraseOverlapIntervals = function (intervals) {

    intervals.sort((a, b) => {

        if (a[0] != b[0]) {
            return a[0] - b[0];
        }
        else {
            return a[1] - b[1];
        }
    });
    let count = 0;
    let prevEnd = intervals[0][1];

    for (let i = 1; i < intervals.length; i++) {

        if (prevEnd > intervals[i][0]) {
            ++count;
            prevEnd = Math.min(prevEnd, intervals[i][1]);
        }
        else {
            prevEnd = intervals[i][1];
        }
    }

    return count;
};



/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function (matrix) {

    let rc = matrix.length;
    let cc = matrix[0].length;
    let isFirstRowZero = false;
    let isFirstColZero = false;

    for (let i = 0; i < rc; i++) {
        if (matrix[i][0] == 0) {
            isFirstColZero = true;
            break;
        }
    }

    for (let i = 0; i < cc; i++) {
        if (matrix[0][i] == 0) {
            isFirstRowZero = true;
            break;
        }
    }

    for (let i = 1; i < rc; i++) {

        for (let j = 1; j < cc; j++) {

            if (matrix[i][j] == 0) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }

    for (let i = 1; i < rc; i++) {
        for (let j = 1; j < cc; j++) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }

    if (isFirstColZero) {
        for (let i = 0; i < rc; i++) {
            matrix[i][0] = 0
        }

    }

    if (isFirstRowZero) {
        for (let i = 0; i < cc; i++) {
            matrix[0][i] = 0
        }

    }
}



Subarray Sum Equals K:

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarraySum = function (nums, k) {

    let map = new Map();
    map.set(0, 1);
    let sum = 0;
    let count = 0;

    for (let num of nums) {

        sum += num;

        if (map.has(sum - k)) {

            count += map.get(sum - k);
        }

        map.set(sum, (map.get(sum) || 0) + 1);
    }
    return count;

};



3Sum:

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {


    nums.sort((a, b) => a - b);
    const ans = [];

    for (let i = 0; i < nums.length - 2; i++) {

        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }

        let left = i + 1;
        let right = nums.length - 1;

        while (left < right) {

            let sum = nums[i] + nums[left] + nums[right];

            if (sum == 0) {

                ans.push([nums[i], nums[left], nums[right]]);
                while (left < right && nums[left] == nums[left + 1]) {
                    ++left;
                }
                while (left < right && nums[right] == nums[right - 1]) {
                    --right;
                }
                ++left;
                --right;
            }
            else if (sum > 0) {

                --right;
            }
            else {
                ++left;
            }
        }
    }
    return ans;
};


Container With Most Water:

/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function (height) {

    let left = 0;
    let right = height.length - 1;
    let ans = -Infinity;

    while (left < right) {

        let cap = (right - left) * Math.min(height[left], height[right]);
        ans = Math.max(ans, cap);

        if (height[left] > height[right]) {
            --right;
        }
        else {
            ++left;
        }
    }

    return ans;

};



Trapping Rain Water:

Solution:

/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function (nums) {


    let left = new Array(nums.length).fill(0);
    let right = new Array(nums.length).fill(0);
    let ans = 0;
    let i = 0;
    left[i] = nums[i];;

    for (let i = 1; i < nums.length; i++) {
        left[i] = Math.max(nums[i], left[i - 1]);
    }
    left[0] = -1;

    right[nums.length - 1] = nums[nums.length - 1];

    for (let i = nums.length - 2; i >= 0; --i) {
        right[i] = Math.max(nums[i], right[i + 1]);
    }

    right[nums.length - 1] = -1

    for (let i = 0; i < nums.length; i++) {
        let c = (Math.min(left[i], right[i]) - nums[i]);
        if (c > 0) {
            ans += c;
        }
    }

    return ans;

};


/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function (nums) {


    let left = 1;
    let right = nums.length - 2;
    let ans = 0;
    let lMax = nums[0];
    let rMax = nums[nums.length - 1];

    while (left <= right) {

        if (rMax > lMax) {

            let cap = (lMax - nums[left]);
            lMax = Math.max(lMax, nums[left]);
            if (cap > 0) {
                ans += cap;
            }
            ++left;
        }
        else {

            let cap = (rMax - nums[right]);
            rMax = Math.max(rMax, nums[right]);
            if (cap > 0) {
                ans += cap;
            }
            --right;
        }
    }



    return ans;


};



Backspace String Compare:

var backspaceCompare = function (s, t) {
    let i = s.length - 1, j = t.length - 1;
    let skipS = 0, skipT = 0;

    while (i >= 0 || j >= 0) {
        // Move i
        while (i >= 0) {
            if (s[i] === '#') { skipS++; i--; }
            else if (skipS > 0) { skipS--; i--; }
            else break;
        }

        // Move j
        while (j >= 0) {
            if (t[j] === '#') { skipT++; j--; }
            else if (skipT > 0) { skipT--; j--; }
            else break;
        }

        let sc = s[i] ? s[i] : null;
        let tc = t[j] ? t[j] : null;

        if (s[i] !== t[j]) {
            return false;
        }
        i--; j--;
    }
    return true;
};




/**
 * @param {string} num
 * @param {number} k
 * @return {string}
 */
var removeKdigits = function (num, k) {


    let stack = [];

    for (let n of num) {

        while (k > 0 && stack.length > 0 && stack[stack.length - 1] > n) {

            stack.pop();
            --k;
        }
        stack.push(n);
    }


    while (k > 0) {
        stack.pop();
        --k;
    }
    while (stack[0] == 0) {

        stack.shift();

    }

    return stack.join('') || '0';
};


/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {


    let seen = new Map();
    let left = 0;
    let ans = 0;

    for (let right = 0; right < s.length; ++right) {

        let c = s[right];

        if (seen.has(c) && seen.get(c) >= left) {
            left = seen.get(c) + 1;
        }

        seen.set(c, right);
        ans = Math.max(ans, right - left + 1);
    }

    return ans;
}



/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var checkInclusion = function (s1, s2) {

    if (s1.length > s2.length) {
        return false;
    }

    let char1 = new Array(26).fill(0);
    let char2 = new Array(26).fill(0);

    let i;

    for (i = 0; i < s1.length; i++) {

        let code1 = s1[i].charCodeAt(0) - 97;
        let code2 = s2[i].charCodeAt(0) - 97;
        ++char1[code1];
        ++char2[code2];
    }

    char1 = char1.join('');

    if (char1 == char2.join('')) {
        return true;
    }

    let j = 0;

    for (i; i < s2.length; i++, j++) {

        let code1 = s2[j].charCodeAt(0) - 97;
        let code2 = s2[i].charCodeAt(0) - 97;
        --char2[code1];
        ++char2[code2];

        if (char1 == char2.join('')) {
            return true;
        }
    }
    return false;
};




/**
 * @param {string} s
 * @param {string} p
 * @return {number[]}
 */
var findAnagrams = function (s2, s1) {

    if (s1.length > s2.length) {

        return [];
    }

    let char1 = new Array(26).fill(0);
    let char2 = new Array(26).fill(0);

    let ans = [];

    let i;

    for (i = 0; i < s1.length; i++) {


        let code1 = s1[i].charCodeAt(0) - 97;
        let code2 = s2[i].charCodeAt(0) - 97;
        ++char1[code1];
        ++char2[code2];
    }

    char1 = char1.join('');

    if (char1 == char2.join('')) {
        ans.push(0);
    }

    let j = 0;

    for (i; i < s2.length; i++) {

        let code1 = s2[j].charCodeAt(0) - 97;
        let code2 = s2[i].charCodeAt(0) - 97;
        ++char2[code2];
        --char2[code1];
        ++j;

        if (char1 == char2.join('')) {
            ans.push(j);
        }
    }

    return ans;

};



/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var characterReplacement = function (s, k) {

    let left = 0;
    let right = 0;
    let ans = -Infinity;
    let chars = new Array(26).fill(0);
    let maxF = 0;

    while (right < s.length) {

        let code = s[right].charCodeAt(0) - 65;
        ++chars[code];

        maxF = Math.max(maxF, chars[code]);

        let length = right - left + 1;

        if (length > (maxF + k)) {

            code = s[left].charCodeAt(0) - 65;
            --chars[code];
            ++left;
        }
        ans = Math.max(ans, right - left + 1);
        ++right

    }

    return ans;
};



Decode Ways:

/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function (s) {


    let map = new Map();
    let cache = new Map();

    for (let i = 0; i < 26; i++) {
        map.set(`${i + 1}`, String.fromCharCode(65 + i));
    }

    let travel = (i) => {


        if (i < 0) {
            return 1;
        }

        if (cache.has(i)) {
            return cache.get(i);
        }

        let res = 0;

        if (map.has(s[i])) {
            res = travel(i - 1);
        }

        if (map.has(s[i - 1] + s[i])) {
            res += travel(i - 2);
        }

        cache.set(i, res);

        return res;
    }
    return travel(s.length - 1);

};



/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var sortColors = function (nums) {


    let i = 0;
    let left = 0;
    let right = nums.length - 1;

    while (i <= right) {


        if (nums[i] == 0) {
            [nums[left], nums[i]] = [nums[i], nums[left]];
            ++left;
            ++i; // incrementing as at pos left 2 never comes as it already moved to right pos.
        }

        else if (nums[i] == 2) {
            [nums[right], nums[i]] = [nums[i], nums[right]];
            --right;
        }
        else {
            ++i;
        }
    }
    return nums;
}



/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function (nums, k) {

    let t = [];
    let ans = [];
    k = k - 1;

    for (let i = 0; i < nums.length; i++) {

        if (t.length && (i - k) > t[0]) {
            t.shift();
        }

        while (t.length && nums[i] >= nums[t[t.length - 1]]) {
            t.pop();
        }

        t.push(i);

        if (i >= k) {
            ans.push(nums[t[0]]);
        }
    }

    return ans;
};



/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function (s, t) {

    const map1 = new Map();
    const map2 = new Map();
    let left = 0;
    let ans = '';

    for (let c of t) {
        map1.set(c, (map1.get(c) || 0) + 1);
    }

    let req = map1.size;
    let have = 0;

    for (let right = 0; right < s.length; ++right) {

        let c = s[right];

        map2.set(c, (map2.get(c) || 0) + 1);

        if (map2.get(c) == map1.get(c)) {
            ++have;
        }

        if (req == have) {

            let start = left;

            while (left <= right) {

                let c = s[left];
                start = left;

                map2.set(c, map2.get(c) - 1);

                if (map1.get(c) > map2.get(c)) {
                    --have;
                    ++left;
                    break;
                }

                ++left;
            }

            if (!ans || ans.length > (right - left + 1)) {
                ans = s.substring(start, right + 1);
            }

        }
    }

    return ans;

};


Reverse Linked List:

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {

    let travel = (p, q) => {

        if (!p) {
            return q;
        }
        let r = p.next;
        p.next = q;
        q = p;

        return travel(r, q);
    }

    return travel(head, null)


};


Merge Two Sorted Lists:

/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function (list1, list2) {

    let head = new ListNode(0, null);
    let temp = head;
    
    while (list1 && list2) {

        if (list1.val >= list2.val) {

            temp.next = list2;
            list2 = list2.next;
        }
        else {
            temp.next = list1;
            list1 = list1.next;
        }

        temp = temp.next;

    }

    if (!list1) {
        temp.next = list2;
    }
    else {
        temp.next = list1;
    }
    return head.next;


};


 Remove Nth Node From End:


/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {

    let s = new ListNode(0, null);
    f = s;
    s.next = head;
    head=s;

    let i = 0;;
    while (i < n) {
        f = f.next;
        ++i;
    }

    while (f.next) {
        f = f.next;
        s = s.next;
    }

    s.next=s.next.next;
    return head.next;

};

Reorder List:

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {void} Do not return anything, modify head in-place instead.
 */
var reorderList = function (head) {

    let reverse = (head) => {
        let p = head;
        let q = null;
        while (p) {
            let r = p.next;
            p.next = q;
            q = p;
            p = r;
        }
        return q;
    }
    
    let slow = head;
    let fast = head;

    while (fast && fast.next && fast.next.next) {
        slow = slow.next;
        fast = fast.next.next;
    }

    let l2 = slow.next;
    let l1 = head;
    slow.next = null;
    l2 = reverse(l2);

    while (l1 && l2) {
        let p = l1.next;
        let q = l2.next;
        l1.next = l2;
        l2.next = p;
        l1 = p;
        l2 = q;
    }
    return head;
};



Linked List Cycle II:


/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {boolean}
 */
var detectCycle = function (head) {

    let slow = head;
    let fast = head;

    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;

        if (slow == fast) {
            slow = head;
            while (slow != fast) {
                slow = slow.next;
                fast = fast.next;
            }
            return slow;
        }
    }
    return null;
};


// Sure üëç here‚Äôs the 4-line explanation of the formula L + x = kC:

// Let L = distance from head to cycle start, x = distance from cycle start to meeting point, C = cycle length.

// At meeting, slow has traveled L + x.

// Fast has traveled L + x + kC (same path as slow + k full cycles).

// Since fast moves twice as fast: L + x + kC = 2(L + x) ‚Üí L + x = kC.

// Would you like me to also give you a one-liner intuition (non-mathy) you can remember easily?



Intersection of Two Linked Lists:

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function (headA, headB) {

    let a = headA;
    let b = headB;

    while (a || b) {

        if (a == null) {
            a = headB
        }
        if (b == null) {
            b = headA;
        }

        if (a == b) {
            return a;
        }
        
        a = a.next;
        b = b.next;

    }
};


/**
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function (nums) {

    nums.unshift(-Infinity);
    nums.push(-Infinity);

    let beg = 1;
    let end = nums.length - 2;

    while (beg <= end) {

        let mid = Math.floor((beg + end) / 2);

        if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {
            return mid - 1;
        }

        if (nums[mid + 1] > nums[mid]) {
            beg = mid + 1;
        }
        else {
            end = mid - 1;
        }
    }
};

/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var searchMatrix = function (matrix, target) {

    let row = matrix.length;
    let col = matrix[0].length;
    let beg = 0;
    let end = row * col - 1;

    while (beg <= end) {

        let mid = (beg + end) >> 1;

        let i = Math.floor(mid / col);
        let j = mid % col;

        if(matrix[i][j]==target){
            return true;
        }
        else if(matrix[i][j]>target){
            end=mid-1;
        }
        else{
            beg=mid+1;
        }
    }
    return false;

};


Search in Rotated Sorted Array:

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function (nums, target) {


    let beg = 0;
    let end = nums.length - 1;

    while (beg <= end) {

        let mid = (beg + end) >> 1;

        if (nums[mid] == target) {
            return mid;
        }
        else if (nums[mid] >= nums[beg]) {

            if (target >= nums[beg] && target < nums[mid]) {

                end = mid - 1;
            }
            else {
                beg = mid + 1;
            }
        }
        else {

            if (target > nums[mid] && target <= nums[end]) {

                beg = mid + 1;
            }
            else {
                end = mid - 1;
            }
        }
    }

    return -1;
};


Find Minimum in Rotated Sorted Array:


/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var findMin = function (nums) {

    let beg = 0;
    let end = nums.length - 1;
    let min = Infinity;


    while (beg <= end) {

        let mid = (beg + end) >> 1;

        if (nums[mid] >= nums[beg]) {

            min = Math.min(min, nums[beg]);
            beg = mid + 1;
        }
        else {
            min = Math.min(min, nums[end]);
            end = mid - 1;
        }
    }

    return min;
};


Koko Eating Bananas:

/**
 * @param {number[]} piles
 * @param {number} h
 * @return {number}
 */
var minEatingSpeed = function (piles, h) {

    const canEatAll = (k) => {

        let count = 0;

        for (let pile of piles) {

            count += (Math.ceil(pile / k));
            if (count > h) {
                return false;
            }
        }
        return true;
    }

    let left = 0;
    let right = Math.max(...piles);
    let ans = Infinity;

    while (left <= right) {

        let mid = (left + right) >> 1;

        if (canEatAll(mid)) {

            ans = Math.min(ans, mid);
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
    }
    return ans;

};


Invert Binary Tree:

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function (root) {


    let travel = (root) => {

        if (!root) {
            return root;
        }

        let left = root.left;
        root.left = root.right;
        root.right = left;

        travel(root.left);
        travel(root.right);
        return root;
    }

    return travel(root)

};



Maximum Depth:

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {


    let depth = (root) => {

        if (!root) {
            return 0;
        }

        let left = 1 + depth(root.left);
        let right = 1 + depth(root.right);

        return Math.max(left,right);
    }

    return depth(root);


}



Balanced Binary Tree:


/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var isBalanced = function (root) {


    let travel = (root) => {

        if (!root) {
            return 0;
        }

        let left = 1 + travel(root.left);
        let right = 1 + travel(root.right);

        if (Math.abs(left - right) > 1) {
            return Infinity;
        }

        return Math.max(left, right);

    }
    return travel(root) == Infinity ? false : true;

};


//Diameter of Binary Tree


/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function (root) {

    let max = -Infinity;

    let travel = (root) => {

        if (!root) {
            return 0;
        }
        let left = 0;

        if (root.left) {
            left = 1 + travel(root.left);
        }

        let right = 0;

        if (root.right) {
            right = 1 + travel(root.right);
        }

        max = Math.max(max, left + right);
        return Math.max(left, right);
    }

    travel(root);
    return max;
};



//Binary Tree Level Order Traversal

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function (root) {

    if (!root) {
        return [];
    }

    let ans = [];

    let queue = [root];

    while (queue.length > 0) {

        let t = [];
        let i = queue.length;

        while (i > 0) {

            let node = queue.shift();
            t.push(node.val);
            if (node.left) {
                queue.push(node.left);
            }
            if (node.right) {
                queue.push(node.right);
            }
            --i;

        }
        ans.push(t);
    }
    return ans;

};


//Right Side View

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function (root) {

    if (!root) {
        return [];
    }

    let queue = [root];
    let ans = [];

    while (queue.length > 0) {

        let size = queue.length;

        for (let i = 0; i < size; i++) {

            let node = queue.shift();

            if (i == size - 1) {
                ans.push(node.val);
            }

            if (node.left) {
                queue.push(node.left);
            }
            if (node.right) {
                queue.push(node.right);
            }
        }
    }
    return ans;
};


//Kth Largest Element


var findKthLargest = function (nums, k) {

    const heap = [];

    const build = (i) => {

        heap.push(nums[i]);
        i = heap.length - 1;
        let p = Math.floor((i - 1) / 2);
        while (p >= 0 && heap[i] > heap[p]) {
            [heap[i], heap[p]] = [heap[p], heap[i]];
            i = p;
            p = Math.floor((i - 1) / 2);
        }
    }

    const heapifyDown = () => {

        let n = heap.length - 1;
        [heap[0], heap[n]] = [heap[n], heap[0]];
        let e = heap.pop();

        let root = 0;
        let p = 0;

        while (true) {

            let left = 2 * root + 1;
            let right = 2 * root + 2;

            if (left <= n && heap[left] > heap[p]) {
                p = left;
            }

            if (right <= n && heap[right] > heap[p]) {
                p = right;
            }
            if (root == p) {
                break;
            }

            [heap[root], heap[p]] = [heap[p], heap[root]];
            root = p;
        }
        return e;
    }

    for (let i = 0; i < nums.length; i++) {
        build(i);
    }

    let ans = -1;

    for (let i = 0; i < k; i++) {
        ans = heapifyDown();
    }
    return ans;

};



carFleet:

/**
 * @param {number} target
 * @param {number[]} position
 * @param {number[]} speed
 * @return {number}
 */
var carFleet = function (target, position, speed) {


    let cars = [];
    let maxTime = 0;
    let count = 0;

    for (let i = 0; i < position.length; i++) {
        let time = (target - position[i]) / speed[i];
        cars.push([position[i], time]);
    }
    cars.sort((a, b) => b[0] - a[0]);

    for (let car of cars) {

        if (car[1] > maxTime) {
            ++count;
            maxTime = car[1];
        }
    }
    return count;


};


//Task Scheduler

/**
 * @param {character[]} tasks
 * @param {number} n
 * @return {number}
 */
var leastInterval = function (tasks, n) {

    let map = new Map();

    for (let task of tasks) {

        if (!map.has(task)) {
            map.set(task, 0);
        }
        map.set(task, map.get(task) + 1);
    }

    let time = 0;
    let heap = [...map.values()];
    let cooldown = [];


    while (heap.length > 0 || cooldown.length > 0) {

        ++time;
        heap.sort((a, b) => b - a);

        if (heap.length > 0) {

            let job = heap.shift() - 1;
            if (job > 0) {
                cooldown.push([time + n, job]);
            }
        }
        if (cooldown.length > 0 && cooldown[0][0] == time) {
            heap.push(cooldown[0][1]);
            cooldown.shift();
        }
    }
    return time;

};



//Largest Rectangle in Histogram

/**
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function (heights) {


    heights.unshift(-Infinity);
    heights.push(-Infinity);

    let left = new Array(heights.length).fill(0);
    let right = new Array(heights.length).fill(0);
    let stk = [];

    for (let i = 0; i < heights.length - 1; i++) {

        if (stk.length == 0) {
            stk.push(i);
            continue;
        }

        while (stk.length > 0 && heights[stk[stk.length - 1]] >= heights[i]) {
            stk.pop();
        }

        left[i] = stk[stk.length - 1];

        stk.push(i);
    }

    stk = [];
    for (let i = heights.length - 1; i > 0; i--) {


        if (stk.length == 0) {
            stk.push(i);
            continue;
        }

        while (stk.length > 0 && heights[stk[stk.length - 1]] >= heights[i]) {
            stk.pop();
        }

        right[i] = stk[stk.length - 1];


        stk.push(i);
    }

    //console.log(left, right);


    let max = -Infinity;

    for (let i = 1; i < heights.length - 1; i++) {

        let w = right[i] - left[i] - 1;

        max = Math.max(max, w * heights[i]);
    }
    return max;

};



// merge-k-sorted-lists


/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function (lists) {

    const heap = [];
    const dummy = new ListNode();
    let head = dummy;

    const heapifyUp = (e) => {
        if (!e) {
            return;
        }


        heap.push(e);

        let n = heap.length - 1;
        let p = Math.floor((n - 1) / 2);
        while (p >= 0 && heap[n].val < heap[p].val) {
            [heap[p], heap[n]] = [heap[n], heap[p]];
            n = p;
            p = Math.floor((n - 1) / 2);
        }
    }

    const heapifyDown = () => {

        let node = heap[0];
        let nextNode = node.next;
        node.next = null;

        if (nextNode) {
            heap[0] = nextNode;
        }
        else {
            heap[0] = heap[heap.length - 1];
            heap.pop();
        }

        let n = heap.length - 1;
        let parent = 0;
        let current = 0;

        while (true) {

            let left = 2 * current + 1;
            let right = 2 * current + 2;

            if (left <= n && heap[left].val < heap[current].val) {
                current = left;
            }

            if (right <= n && heap[right].val < heap[current].val) {
                current = right;
            }

            if (parent == current) {
                break;
            }

            [heap[parent], heap[current]] = [heap[current], heap[parent]];

            parent = current;
        }
        return node;
    }

    for (let list of lists) {

        heapifyUp(list);
    }
    //console.log(heap);

    while (heap.length > 0) {
        head.next = heapifyDown();
        head = head.next;
        //console.log(head.val, heap)
    }

    return dummy.next;

};




//Find Median from Data Stream
//For every insertion move max from left to right and min from right to left.

let left = [];
let right = [];

let leftPush = function (num) {

    left.push(num);
    let n = left.length - 1;
    let i = Math.floor((n - 1) / 2);
    while (i >= 0 && left[n] > left[i]) {

        [left[i], left[n]] = [left[n], left[i]];
        n = i;
        i = Math.floor((n - 1) / 2);
    }
}

let rightPush = function (num) {

    right.push(num);
    let n = right.length - 1;
    let i = Math.floor((n - 1) / 2);
    while (i >= 0 && right[n] < right[i]) {

        [right[i], right[n]] = [right[n], right[i]];
        n = i;
        i = Math.floor((n - 1) / 2);
    }
}

let leftDown = function () {

    let current = 0;
    let root = 0;
    let n = left.length;
    while (true) {

        let i = 2 * current + 1; //left child
        let j = 2 * current + 2; // right child

        if (i < n && left[i] > left[current]) {
            current = i;
        }
        if (j < n && left[j] > left[current]) {
            current = j;
        }

        if (current == root) {
            break;
        }
        [left[current], left[root]] = [left[root], left[current]];
        root = current;

    }
}

let rightDown = function () {
    let current = 0;
    let root = 0;
    let n = left.length;
    while (true) {

        let i = 2 * current + 1; //left child
        let j = 2 * current + 2; // right child

        if (i < n && right[i] < right[current]) {
            current = i;
        }
        if (j < n && right[j] < right[current]) {
            current = j;
        }
        if (current == root) {
            break;
        }
        [right[current], right[root]] = [right[root], right[current]];
        root = current;
    }
}

var MedianFinder = function () {
    left = [];
    right = [];
};
/** 
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function (num) {

    leftPush(num);
    let e = left[0];
    left[0] = left[left.length - 1];
    left.pop();
    leftDown();
    rightPush(e);
    if (right.length > left.length) {

        //console.log(left, right)

        let e = right[0];
        right[0] = right[right.length - 1];
        right.pop();
        rightDown();
        leftPush(e);
    }
};

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function () {

    if ((left.length + right.length) % 2 == 0) {

        return (left[0] + right[0]) / 2;
    }
    else {
        return left[0];
    }
};

/** 
 * Your MedianFinder object will be instantiated and called as such:
 * var obj = new MedianFinder()
 * obj.addNum(num)
 * var param_2 = obj.findMedian()
 */



//Number of Islands

/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function (grid) {

    let rows = grid.length;
    let cols = grid[0].length;

    let count = 0;

    let travel = (i, j) => {

        if (i < 0 || j < 0 || i >= rows || j >= cols || grid[i][j] == "0") {
            return;
        }

        grid[i][j] = "0";
        travel(i + 1, j);
        travel(i - 1, j);
        travel(i, j + 1);
        travel(i, j - 1);

    }

    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {

            if (grid[i][j] == "1") {

                ++count;
                travel(i, j);
            }
        }
    }

    return count;

};


/**
 * // Definition for a _Node.
 * function _Node(val, neighbors) {
 *    this.val = val === undefined ? 0 : val;
 *    this.neighbors = neighbors === undefined ? [] : neighbors;
 * };
 */

/**
 * @param {_Node} node
 * @return {_Node}
 */
var cloneGraph = function (node) {

    if (!node) {
        return node;
    }

    let nc = new _Node();
    let vis = new Map();

    console.log(node);

    let travel = (nc, node) => {

        //console.log(nc, node)

        if (vis.has(node.val)) {
            return vis.get(node.val);
        }

        vis.set(node.val,nc);

        nc.val = node.val;

        for (let nbr of node.neighbors) {

            let n1 = new _Node();
            nc.neighbors.push(travel(n1, nbr));
            
        }
        return nc;
    }
    let ans=travel(nc, node);

    console.log(ans);
    return ans;
};


//Rotting Oranges

/**
 * @param {number[][]} grid
 * @return {number}
 */
var orangesRotting = function (grid) {

    let count = 0;
    let queue = [];
    let m = grid.length;
    let n = grid[0].length;

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {

            if (grid[i][j] == 2) {
                queue.push([i, j]);

            }
        }
    }
    //console.log(queue)

    while (queue.length > 0) {

        let t = [];
        for (let node of queue) {

            let [i, j] = node;


            if ((i - 1) >= 0) {

                if (grid[i - 1][j] == 1) {

                    grid[i - 1][j] = 2;
                    t.push([i - 1, j])
                }
            }
            if ((i + 1) < m) {

                if (grid[i + 1][j] == 1) {

                    grid[i + 1][j] = 2;

                    t.push([i + 1, j])
                }
            }

            if ((j - 1) >= 0) {
                if (grid[i][j - 1] == 1) {

                    grid[i][j - 1] = 2;
                    t.push([i, j - 1])
                }
            }
            if ((j + 1) < n) {

                if (grid[i][j + 1] == 1) {

                    grid[i][j + 1] = 2;
                    t.push([i, j + 1])
                }
            }
        }
        queue = t;
        if (queue.length > 0) {
            ++count;
        }

    }

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {

            if (grid[i][j] == 1) {
                return -1;

            }
        }
    }

    return count;

};

//console.log(orangesRotting([[1,2]]))


//Pacific Atlantic Water Flow

/**
 * @param {number[][]} heights
 * @return {number[][]}
 */
var pacificAtlantic = function (heights) {


    let rows = heights.length;
    let cols = heights[0].length;
    let ans = [];
    let pacific = [];
    let atlantic = [];

    for (let i = 0; i < rows; i++) {

        pacific.push(new Array(cols).fill(false));
        atlantic.push(new Array(cols).fill(false));
    }

    let travel = (row, col, vis, pHeight) => {

        if (row < 0 || col < 0 || row >= rows || col >= cols
            || vis[row][col] || pHeight > heights[row][col]) {
            return;
        }
        vis[row][col] = true;
        travel(row + 1, col, vis, heights[row][col]);
        travel(row - 1, col, vis, heights[row][col]);
        travel(row, col + 1, vis, heights[row][col]);
        travel(row, col - 1, vis, heights[row][col]);


    }

    for (let i = 0; i < rows; i++) {
        travel(i, 0, pacific, -Infinity)
        travel(i, cols - 1, atlantic, -Infinity)
    }

    for (let i = 0; i < cols; i++) {
        travel(0, i, pacific, -Infinity)
        travel(rows - 1, i, atlantic, -Infinity)
    }

    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (pacific[i][j] && atlantic[i][j]) {
                ans.push([i, j]);
            }
        }
    }
    return ans;
};


//Course Schedule 1

/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
var canFinish = function (numCourses, prerequisites) {

    const g = new Map();
    const visited = new Array(numCourses).fill(false);
    const inStack = new Array(numCourses).fill(false);

    for (let [v, u] of prerequisites) {

        if (!g.has(u)) {
            g.set(u, []);
        }

        g.get(u).push(v);
    }

    let dfs = (start) => {

        // if (inStack[start]) {
        //     return true;
        // }

        if (visited[start]) {
            return true;
        }


        visited[start] = true;
        //inStack[start] = true;

        const nbrs = g.get(start) || [];

        for (const nbr of nbrs) {

            if (dfs(nbr)) {
                return true;
            }

        }
        //inStack[start] = false;
        return false;
    }

    for (let i = 0; i < numCourses; i++) {
        if (!visited[i] && dfs(i)) {
            return false;
        }
    }
    return true;

};

// Find cycle exists or not.

//Course Schedule 2


/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
var findOrder = function (numCourses, prerequisites) {

    let g = new Map();
    let ans = [];

    for (let [u, v] of prerequisites) {

        if (!g.has(v)) {
            g.set(v, []);
        }
        g.get(v).push(u);
    }

    let vis = new Map();
    let stateMap = new Map();

    let isCycle = (i) => {

        if (stateMap.has(i)) {
            return true;
        }

        if (vis.has(i)) {
            return false;
        }

        vis.set(i, true);
        stateMap.set(i, true);

        let nbrs = g.get(i) || [];

        for (let nbr of nbrs) {

            let res = isCycle(nbr);
            if (res) {
                return res;
            }
        }
        stateMap.delete(i);
        ans.push(i);
        return false;
    }

    for (let i = 0; i < numCourses; i++) {
        let res = isCycle(i);
        if (res) {
            return [];
        }
    }
    return ans.reverse();
};


//Graph Valid Tree

class Solution {
    // Function to check whether the given graph is a tree or not.
    isTree(n, adj) {
        let edges = [];
        let map = new Map();

        // collect unique edges
        for (let i = 0; i < n; i++) {
            let nbrs = adj[i] || [];
            for (let nbr of nbrs) {
                let key1 = `${i}_${nbr}`;
                let key2 = `${nbr}_${i}`;
                if (!map.has(key1) && !map.has(key2)) {
                    map.set(key1, true);
                    edges.push([i, nbr]);
                }
            }
        }

        // check edge count
        if (edges.length !== n - 1) return 0;

        let p = new Array(n).fill(0).map((_, i) => i);

        let getParent = (u) => {
            if (p[u] !== u) p[u] = getParent(p[u]);
            return p[u];
        };

        let merge = (u, v) => {
            let pu = getParent(u);
            let pv = getParent(v);
            if (pu === pv) return false; // cycle
            p[pv] = pu; // ‚úÖ correct union
            return true;
        };

        // check for cycles
        for (let [u, v] of edges) {
            if (!merge(u, v)) return 0;
        }

        // ensure connected (only 1 component)
        let count = 0;
        for (let i = 0; i < n; i++) {
            if (p[i] === i) count++;
        }
        return count === 1 ? 1 : 0;
    }
}



//Alien Dictionary

class Solution {
    findOrder(words) {
        let graph = new Map();
        let chars = new Set();

        // Collect all characters
        for (let word of words) {
            for (let ch of word) {
                let code = ch.charCodeAt(0) - 'a'.charCodeAt(0);
                chars.add(code);
                if (!graph.has(code)) {
                    graph.set(code, []);
                }
            }
        }

        // Build graph
        for (let i = 0; i < words.length - 1; i++) {
            let w1 = words[i];
            let w2 = words[i + 1];
            let minLen = Math.min(w1.length, w2.length);

            let j = 0;
            for (; j < minLen; j++) {
                if (w1[j] !== w2[j]) {
                    let u = w1[j].charCodeAt(0) - 'a'.charCodeAt(0);
                    let v = w2[j].charCodeAt(0) - 'a'.charCodeAt(0);
                    graph.get(u).push(v);
                    break;
                }
            }
            // Handle prefix edge case: if all characters matched but first word is longer
            if (j === minLen && w1.length > w2.length) {
                return "";
            }
        }

        let visited = Array(26).fill(false);
        let inStack = Array(26).fill(false);
        let result = [];
        let hasCycle = false;

        const dfs = (node) => {
            if (inStack[node]) return false; // Cycle detected
            if (visited[node]) return true;

            visited[node] = true;
            inStack[node] = true;

            for (let neighbor of graph.get(node) || []) {
                if (!dfs(neighbor)) return false;
            }

            inStack[node] = false;
            result.push(String.fromCharCode(node + 'a'.charCodeAt(0)));
            return true;
        };

        for (let ch of chars) {
            if (!visited[ch]) {
                if (!dfs(ch)) return ""; // cycle found, invalid order
            }
        }

        return result.reverse().join('');
    }
}




//Redundant Connection:

/**
 * @param {number[][]} edges
 * @return {number[]}
 */
var findRedundantConnection = function (edges) {

    let vertices = new Set();
    const ans = [];

    for (let [u, v] of edges) {

        vertices.add(u);
        vertices.add(v);

    }

    let p = new Array(vertices.size + 1).fill(0).map((v, i) => i);
    let size = new Array(vertices.size + 1).fill(0);



    let getParent = (u) => {

        if (p[u] != u) {

            p[u] = getParent(p[u]);
        }
        return p[u];
    }

    let merge = (u, v) => {

        let pu = getParent(u);
        let pv = getParent(v);

        if (pu == pv) {
            return false;
        }

        if (size[pu] >= size[pv]) {
            p[pv] = pu;
            ++size[pu];
        }
        else {
            p[pu] = p[pv];
            ++size[pv];
        }

        return true;


    }

    for (let [u, v] of edges) {

        let res = merge(u, v);

        if (!res) {

            ans.push([u, v]);
        }
    }
    return ans[ans.length - 1];
};



//Network Delay(Djekstra)

/**
 * @param {number[][]} times
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
var networkDelayTime = function (times, n, k) {


    const dis = new Array(n + 1).fill(Infinity);
    const g = new Map();

    for (let [u, v, w] of times) {

        if (!g.has(u)) {

            g.set(u, []);

        }
        if (!g.has(v)) {
            g.set(v, []);
        }
        g.get(u).push([v, w]);
    }


    dis[k] = 0;


    const queue = [[k, 0]];

    while (queue.length > 0) {

        //queue.sort((a, b) => a - b);
        let [u, w1] = queue.shift();

        if (w1 > dis[u]) {
            continue;
        }

        let adj = g.get(u) || [];

        for (let [v, w2] of adj) {

            let cost = w1 + w2;

            if (dis[v] > cost) {
                dis[v] = cost;
                queue.push([v, cost]);
            }
        }
    }

    dis.shift();


    return Math.max(...dis) == Infinity ? -1 : Math.max(...dis);

};




//Generate Parentheses,


/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function (n) {



    let ans = [];

    let travel = (s, open, close) => {

        if ((close + open) == 2 * n) {
            ans.push(s);
            return;
        }

        if (open < n) {
            travel(s + "(", open + 1, close);
        }

        if (close < open) {
            travel(s + ")", open, close + 1);
        }


    }

    travel("", 0, 0);

    return ans;

};



//Permutations

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function (nums) {


    let ans = [];
    let n = nums.length;
    let map = new Map();

    const travel = (t) => {


        if (t.length == nums.length) {
            ans.push([...t]);
        }

        for (let i = 0; i < n; i++) {

            if (map.has(i)) {
                continue;
            }

            map.set(i, true);
            t.push(nums[i]);
            travel(t);
            map.delete(i);
            t.pop();
        }
    }

    travel([]);

    return ans;

};


//permute(['a', 'b', 'c'])


//Subsets

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function (nums) {

    let ans = [];

    let travel = (i, t) => {

        if (i == nums.length) {
            ans.push([...t]);
            return;
        }
        travel(i + 1, t);
        t.push(nums[i]);
        travel(i + 1, t);

        t.pop();
    }
    travel(0, []);

    return ans;
};


/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function (candidates, target) {
    let ans = [];
    let map = new Map();

    let travel = (i, t, sum) => {

        if (sum == 0 && !map.has(t.join(','))) {
            ans.push([...t]);
            map.set(t.join(','))
        }
        if (sum < 0 || i == candidates.length) {
            return;
        }

        travel(i + 1, t, sum);
        t.push(candidates[i]);
        travel(i, t, sum - candidates[i]);
        t.pop();
    }

    travel(0, [], target);


    return ans;
};

//Word Search

/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function (board, word) {

    let m = board.length;
    let n = board[0].length;

    let travel = (i, j, str) => {


        if (str == word) {
            return true;
        }

        if (str[str.length - 1] != word[str.length - 1]) {
            return false;
        }

        let char = board[i][j];
        board[i][j] = '#';

        let dirs = [
            [-1, 0],
            [1, 0],
            [0, -1],
            [0, 1]
        ];

        for (let [dx, dy] of dirs) {

            let x = i + dx;
            let y = j + dy;

            if (x < 0 || y < 0 || x >= m || y >= n || board[x][y] == '#') {
                continue;
            }

            let isMatchFound = travel(x, y, str + board[x][y]);
            if (isMatchFound) {
                return isMatchFound;
            }
        }

        board[i][j] = char;
        return false;
    }

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {

            let isMatchFound = travel(i, j, board[i][j]);
            if (isMatchFound) {
                return isMatchFound;
            }
        }
    }




    return false;
};


// Number of Islands  ==> BFS
/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function (grid) {

    let count = 0;
    let rows = grid.length;
    let cols = grid[0].length;

    let travel = (i, j) => {

        let queue = [[i, j]];

        while (queue.length > 0) {

            let n = queue.length;

            for (let k = 0; k < n; k++) {

                let [i, j] = queue.shift();

                if ((i + 1) < rows && grid[i + 1][j] == 1) {
                    grid[i + 1][j] = 0;
                    queue.push([i + 1, j]);
                }
                if ((i - 1) < 0 && grid[i - 1][j] == 1) {
                    grid[i - 1][j] = 0;
                    queue.push([i - 1, j]);
                }
                if ((j + 1) < cols && grid[i][j + 1] == 1) {
                    grid[i][j + 1] = 0;
                    queue.push([i, j + 1]);
                }
                if ((j - 1) < 0 && grid[i][j - 1] == 1) {
                    grid[i][j - 1] = 0;
                    queue.push([i, j - 1]);
                }


            }
        }
    }

    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (grid[i][j] == 1) {
                ++count;
                travel(i, j);
            }
        }
    }
    return count;
};

/*
TC: 
m*n
SC:
m*n for grid
m*n for stack


*/

// Number of Islands.  DFS:

/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function (grid) {

    let count = 0;
    let rows = grid.length;
    let cols = grid[0].length;

    let travel = (i, j) => {

        if (i >= rows || i < 0 || j >= cols || j < 0 || grid[i][j] == 0) {
            return
        }

        grid[i][j] = 0;

        travel(i - 1, j);
        travel(i + 1, j);
        travel(i, j + 1);
        travel(i, j - 1);
    }

    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (grid[i][j] == 1) {
                ++count;
                travel(i, j);
            }
        }
    }
    return count;
};


// Implement try



var Trie = function () {
    this.chars = new Array(26).fill(null);
    this.isEnd = false;

};

/** 
 * @param {string} word
 * @return {void}
 */
Trie.prototype.insert = function (word) {

    let node = this;

    for (let c of word) {

        let code = c.charCodeAt(0) - 97;
        if (node.chars[code]) {
            node = node.chars[code];
        }
        else {
            node.chars[code] = new Trie();
            node = node.chars[code];
        }
    }
    node.isEnd = true;

};

/** 
 * @param {string} word
 * @return {boolean}
 */
Trie.prototype.search = function (word) {

    let node = this;

    for (let c of word) {

        let code = c.charCodeAt(0) - 97;
        if (node.chars[code]) {
            node = node.chars[code];
        }
        else {
            return false;
        }
    }
    if (node.isEnd) {
        return true;
    }
    return false;
};

/** 
 * @param {string} prefix
 * @return {boolean}
 */
Trie.prototype.startsWith = function (prefix) {
    let node = this;
    for (let c of prefix) {

        let code = c.charCodeAt(0) - 97;
        if (node.chars[code]) {
            node = node.chars[code];
        }
        else {
            return false;
        }
    }
    return true;

};

/** 
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */


// Add and Search Word


var WordDictionary = function () {

    this.children = new Map();
    this.end = false;

};

/** 
 * @param {string} word
 * @return {void}
 */
WordDictionary.prototype.addWord = function (word) {

    let node = this;

    for (let c of word) {

        if (node.children.has(c)) {
            node = node.children.get(c);
        }
        else {
            let child = new WordDictionary();
            node.children.set(c, child);
            node = child;
        }
    }
    node.end = true;

};

/** 
 * @param {string} word
 * @return {boolean}
 */
WordDictionary.prototype.search = function (word, node = null) {

    if (!node) {
        node = this;
    }

    for (let i = 0; i < word.length; i++) {
        let c = word[i];

        if (node.children.has(c)) {
            node = node.children.get(c);
        }
        else {
            if (c == ".") {

                let newWord = word.substring(i + 1);

                for (let i = 0; i < 26; i++) {

                    let char = String.fromCharCode(97 + i);
                    if (node.children.has(char)) {
                        let res = this.search(newWord, node.children.get(char));
                        if (res) {
                            return true;
                        }
                    }
                }
                return false;
            }
            else {
                return false;
            }
        }
    }
    if (node.end) {
        return true;
    }
    else {
        return false;
    }

};

/** 
 * Your WordDictionary object will be instantiated and called as such:
 * var obj = new WordDictionary()
 * obj.addWord(word)
 * var param_2 = obj.search(word)
 */


//Top K Frequent Words

/**
 * @param {string[]} words
 * @param {number} k
 * @return {string[]}
 */
var topKFrequent = function (words, k) {

    let map = new Map();

    for (let word of words) {

        if (!map.has(word)) {
            map.set(word, 0);
        }

        map.set(word, map.get(word) + 1);
    }

    let f = new Map();
    let max = -Infinity;

    for (let word of map.keys()) {

        let frequency = map.get(word);
        max = Math.max(max, frequency);
        if (!f.has(frequency)) {

            f.set(frequency, []);
        }

        f.get(frequency).push(word)
    }

    let ans = [];

    for (let i = max; i > 0; --i) {
        let words = f.get(i);
        if (words) {
            words.sort();
            ans.push(...words);
        }
        if(ans.length>=k){
            ans=ans.slice(0,k+1);
            break;
        }
    }

    return ans;

};



//Encode/Decode Strings


// User function Template for javascript
/**
 * @param {string[]} strs
 * @returns {string}
 */

class Solution {
    // Function to encode a list of strings to a single string.
    encode(words) {

        let encodedStr = "";

        for (let word of words) {

            encodedStr += (word.length) + "#" + word;

        }
        return encodedStr;


    }

    // Function to decode a single string to a list of strings.
    decode(s) {
        //console.log(s)

        let i = 0;
        let ans=[];

        while (i<s.length) {

            let j = i;
            while (s[j] != "#") {

                j++;

            }
            let len=parseInt(s.substring(i,j));
            ans.push(s.substring(j+1,j+1+len));
            i=j+1+len;
        }

        return ans;

        // 2#ab3#abc


    }
}



//Climbing Stairs

/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {

    const dp = new Array(n + 1).fill(-1);

    let travel = (n) => {

        if (n == 0) {
            return 1;
        }
        if (n < 0) {
            return 0;
        }

        if (dp[n] != -1) {
            return dp[n];
        }
        return dp[n] = (travel(n - 1) + travel(n - 2));
    }

    return travel(n);

};


/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {

    const dp = new Array(n + 1).fill(-1);

    dp[0] = 1

    for (let i = 1; i <= n; i++) {

        dp[i] = dp[n - 1] + dp[n - 2] || 0;

    }

    return dp[n];

};



/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {

    let dp = new Array(nums.length + 1).fill(-1);


    let travel = (i) => {

        if (i < 0) {
            return 0;
        }
        if (dp[i] != -1) {
            return dp[i];
        }

        let s1 = nums[i] + travel(i - 2);
        let s2 = travel(i - 1);

        return dp[i] = Math.max(s1, s2);
    }
    return travel(nums.length - 1);
};



/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {

    let dp = new Array(nums.length + 1).fill(-1);


    let travel = (i) => {

        if (i < 0) {
            return 0;
        }
        if (dp[i] != -1) {
            return dp[i];
        }

        let s1 = nums[i] + travel(i - 2);
        let s2 = travel(i - 1);

        return dp[i] = Math.max(s1, s2);
    }
    return travel(nums.length - 1);
};



/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {

    let dp = new Array(nums.length + 1).fill(-1);

    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1] || 0);


    for (let i = 2; i < nums.length; i++) {

        let s1 = nums[i] + dp[i - 2];
        let s2 = dp[i - 1];

        dp[i] = Math.max(s1, s2);

    }
    return dp[nums.length - 1];
};




//House Robber II

/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {

    if (nums.length == 1) {
        return nums[0];
    }

    let dp = new Array(nums.length + 1).fill(-1);


    let travel = (i, nums) => {

        if (i >= nums.length) {
            return 0;
        }
        if (dp[i] != -1) {
            return dp[i];
        }

        let s1 = nums[i] + travel(i + 2, nums);
        let s2 = travel(i + 1, nums);

        return dp[i] = Math.max(s1, s2);
    }
    let ans1 = travel(0, nums.slice(0, nums.length - 1));
    dp = new Array(nums.length + 1).fill(-1);
    let ans2 = travel(0, nums.slice(1));
    return Math.max(ans1, ans2);
};



//Maximum Subarray

/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {

    let sum = 0;
    let max = -Infinity;

    for (let i = 0; i < nums.length; i++) {

        if (sum < 0) {
            sum = nums[i];
        }
        else {
            sum += nums[i];
        }
        max = Math.max(sum, max);
    }

    return max;
};


//Maximum Product Subarray

/**
 * @param {number[]} nums
 * @return {number}
 */
var maxProduct = function (nums) {


    let max = -Infinity;
    let product = 1;

    for (let i = 0; i < nums.length; i++) {

        if (product == 0) {
            product = nums[i];
        }
        else {
            product *= nums[i];
        }

        max = Math.max(max, product);

    }

    product = 1;

    for (let i = nums.length - 1; i >= 0; i--) {

        if (product == 0) {
            product = nums[i];
        }
        else {
            product *= nums[i];
        }

        max = Math.max(max, product);

    }
    return max;
};


//Coin Change

/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function (coins, amount) {


    let travel = (i, amount) => {

        if (amount == 0) {
            return 0;
        }
        if (amount < 0 || i < 0) {
            return Infinity;
        }

        let count1 = 1 + travel(i, amount - coins[i])
        let count2 = travel(i - 1, amount);

        return Math.min(count1, count2);
    }

    let ans = travel(coins.length - 1, amount);


    return ans == Infinity ? -1 : ans;

};



// Coin Change II

/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var change = function (amount, coins) {


    let travel = (i, amount) => {

        if (amount == 0) {
            return 1;
        }
        if (amount < 0 || i < 0) {
            return 0;
        }

        let count1 = travel(i, amount - coins[i])
        let count2 = travel(i - 1, amount);

        return count1+count2;
    }

    let ans = travel(coins.length - 1, amount);


    return ans;

};


//Decode Ways

/**
 * @param {string} s
 * @return {number}
 */
var numDecodings = function (s) {


    const map = new Map();
    const dp = new Array(s.length).fill(-1);

    for (let i = 1; i <= 26; i++) {
        map.set(`${i}`, "");
    }

    let travel = (i) => {

        if (i < 0) {
            return 1;
        }

        if (dp[i] != -1) {
            return dp[i];
        }

        let count1 = 0;
        let count2 = 0;

        if (s[i] != "0") {
            count1 = travel(i - 1);
        }

        if ((i - 1) >= 0 && map.has(`${s[i - 1]}${s[i]}`)) {
            count2 = travel(i - 2);
        }
        return dp[i] = (count1 + count2);
    }
    return travel(s.length - 1);
};



//Word Break (DP view),

/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function (s, wordDict) {


    const map = new Map();
    const dp = new Array(s.length + 1).fill(null);

    for (let word of wordDict) {
        map.set(word, "");
    }


    const travel = (i) => {

        if (i == s.length) {
            return true;
        }

        if (dp[i] != null) {
            return dp[i];
        }

        for (let j = i; j < s.length; j++) {

            let word = s.substring(i, j + 1);

            if (map.has(word)) {
                let ans = travel(j + 1);
                if (ans) {
                    return ans;
                }
            }
        }
        return dp[i] = false;
    }

    return travel(0);

};


//Unique Paths

/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function (m, n) {



    let travel = (i, j) => {

        if (i >= m || j >= n) {
            return 0;
        }

        if (i == m - 1 && j == n - 1) {
            return 1;
        }

        return (travel(i + 1, j) + travel(i, j + 1));

    }

    return travel(0, 0);


};


//Longest Increasing Subsequence

/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function (nums) {

    const dp = new Array(nums.length).fill(new Array(nums.length));


    let travel = (i, j) => {

        if (i < 0) {
            return 0;
        }

        if (dp[i][j]) {
            return dp[i][j];
        }

        let count1 = 0;
        let count2 = 0;

        if (j == -1 || nums[i] < nums[j]) {
            count1 = 1 + travel(i - 1, i);
        }
        count2 = travel(i - 1, j);

        return dp[i][j] = Math.max(count1, count2);

    }

    return travel(nums.length - 1, -1);

};



//Russian Doll Envelopes (if in pool)


/**
 * @param {number[][]} envelopes
 * @return {number}
 */
var maxEnvelopes = function (envelopes) {


    envelopes.sort((a, b) => a[0] - b[0]);

    const dp = [];

    for (let i = 0; i < envelopes.length; i++) {
        dp.push(new Array(envelopes.length).fill(null));
    }

    let travel = (i, j) => {

        if (i >= envelopes.length) {
            return 0;
        }

        if (j !== -1 && dp[i][j] !== null) {
            return dp[i][j];
        }

        let count1 = 0;
        let count2 = 0;

        if (j == -1 || (envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1])) {
            count1 = 1 + travel(i + 1, i);
        }

        count2 = travel(i + 1, j);

        let ans = Math.max(count1, count2);
        if (j !== -1)
            dp[i][j] = ans;

        return ans;
    }
    return travel(0, -1);

};



